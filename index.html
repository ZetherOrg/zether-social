<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag -->
  <script async src='https://www.googletagmanager.com/gtag/js?id=G-Z80J9QWSV6'></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-Z80J9QWSV6');
  </script>
  
  <meta charset="UTF-8" />
  <!-- Basic Page Info -->
  <title>Zether - Decentralized Social Platform</title>
  <link rel="icon" type="image/png" href="img/logo.png">
  <meta name="description" content="Zether is a decentralized, adminless social platform built entirely on a single smart contract—no servers, no moderators, and no censorship." />
  <meta name="keywords" content="Zether, blockchain, decentralized, social media, no censorship, Web3" />
  <meta name="author" content="Zether Team" />

  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Zether">
  <meta property="og:description" content="Zether is a decentralized, adminless social platform built entirely on a single smart contract — no servers, no moderators, and no censorship.">
  <meta property="og:image" content="https://zether.org/img/card.png">
  <meta property="og:url" content="https://zether.org/">
  <meta property="og:type" content="website">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Zether">
  <meta name="twitter:description" content="Zether is a decentralized, adminless social platform built entirely on a single smart contract — no servers, no moderators, and no censorship.">
  <meta name="twitter:image" content="https://zether.org/img/card.png">
  <meta name="twitter:site" content="@ZetherOrg">
  <meta name="twitter:creator" content="@ZetherOrg">

  <!-- Marked for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  
  <!-- Font Awesome! -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" crossorigin="anonymous">

  <style>
    /* ============================= THEME VARIABLES ============================= */
    :root {
      --transition-speed: 0.3s;

      /* Light Theme Palettes */
      --color-light-bg: #ffffff;
      --color-light-text: #242526;
      --color-light-secondary: #f2f3f5;
      --color-light-border: #d7d7d7;
      --color-light-accent: #1da1f3;
      --color-light-danger: #e0245e;
      --color-light-success: #17bf63;
      
      /* Dim Theme Palettes */
      --color-dim-bg: #15202b;
      --color-dim-text: #e9ecef;
      --color-dim-secondary: #1e2732;
      --color-dim-border: #2f3b45;
      --color-dim-accent: #1da1f3;
      --color-dim-danger: #e0245e;
      --color-dim-success: #17bf63;

      /* Dark Theme Palettes */
      --color-dark-bg: #000000;
      --color-dark-text: #e7e9ea;
      --color-dark-secondary: #121212;
      --color-dark-border: #2f3336;
      --color-dark-accent: #1da1f3;
      --color-dark-danger: #e0245e;
      --color-dark-success: #17bf63;
    }

    /* Each theme class picks which palette to use */
    .light-theme {
      --bg: var(--color-light-bg);
      --text: var(--color-light-text);
      --secondary: var(--color-light-secondary);
      --border: var(--color-light-border);
      --accent: var(--color-light-accent);
      --danger: var(--color-light-danger);
      --success: var(--color-light-success);
    }
    .dim-theme {
      --bg: var(--color-dim-bg);
      --text: var(--color-dim-text);
      --secondary: var(--color-dim-secondary);
      --border: var(--color-dim-border);
      --accent: var(--color-dim-accent);
      --danger: var(--color-dim-danger);
      --success: var(--color-dim-success);
    }
    .dark-theme {
      --bg: var(--color-dark-bg);
      --text: var(--color-dark-text);
      --secondary: var(--color-dark-secondary);
      --border: var(--color-dark-border);
      --accent: var(--color-dark-accent);
      --danger: var(--color-dark-danger);
      --success: var(--color-dark-success);
    }

    /* ============================= GLOBAL STYLES ============================= */
    * {
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
    }
    html {
      scroll-behavior: smooth;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding-bottom: 50px;
      line-height: 1.5;
      transition: background var(--transition-speed), color var(--transition-speed);
    }
    a {
      color: var(--accent);
      text-decoration: none;
      line-break: anywhere;
    }
    a:hover {
      text-decoration: underline;
    }
    button {
      cursor: pointer;
      transition: background 0.2s, border 0.2s;
      border: none;
    }
    .postText pre {
      padding-top: 10px;
      padding-bottom: 15px;
      line-height: 1.2;
    }
    code {
      color: #53979a;
      font-size: 0.9rem;
    }
    p {
      padding-bottom: 10px;
      /* word-break: break-all; */
      overflow-wrap: break-word;
    }
    p img {
      max-width: 30vw;
      height: auto;
      margin-top: 10px;
      margin-bottom: 10px;
      display: block;
    }
    i {
      color: var(--text);
    }
    ol, ul {
      padding-left: 25px;
      padding-bottom: 10px;
    }
    .postText h1,
    .postText h2,
    .postText h3,
    .postText h4 {
      padding: 10px 0;
    }

    /* ============================= LOADER ============================= */
    #loader {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,255,255,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .dim-theme #loader,
    .dark-theme #loader {
      background: rgba(0,0,0,0.7);
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--accent);
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0%   { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* ============================= TOP BAR & NAV ============================= */
    #topBar {
      background: var(--secondary);
      color: var(--text);
      padding: 12px 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      transition: background var(--transition-speed), color var(--transition-speed);
      z-index: 100;
    }
    #topBar h1 {
      font-size: 18px;
      font-weight: 600;
    }
    /* Theme Toggle Container */
    .themeToggle {
      position: absolute;
      right: 200px; 
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
    }
    .themeToggle select {
      background: var(--secondary);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 4px 10px;
      border-radius: 6px;
      outline: none;
    }
    .connectSection {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .connectSection button {
      background: var(--accent);
      color: #fff;
      padding: 6px 12px;
      font-weight: 600;
      border-radius: 20px;
    }
    .connectSection button:hover {
      background: #1387c7; /* slightly darker accent on hover */
    }
    #logoutBtn {
      background: var(--danger);
      color: #fff;
      border-radius: 20px;
      padding: 6px 12px;
      font-weight: 600;
    }
    #logoutBtn:hover {
      background: #b91b4b;
    }

    /* ============================= MAIN LAYOUT ============================= */
    #layout {
      display: grid;
      justify-content: center;
      grid-template-columns: 20vw 50vw 20vw; /* narrower sidebars, more main content */
      gap: 20px;
      padding: 20px;
      margin-top: 1px;
    }
    .adsDiv {
      display: block;
      margin-top: 30px;
    }
    @media (max-width: 1200px) {
      #topBar {
        justify-content: flex-start;
      }
      #layout {
        grid-template-columns: 1fr;
      }
      #mainContent {
        max-height: 80vh;
        overflow-y: auto;
      }
      #rightSide {
        max-height: 100%;
        overflow-y: auto;
      }
      .navMenuDiv {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 10px;
      }
      .adsDiv {
        margin-top: auto;
        text-align: center;
      }
    }

    /* ============================= SIDEBAR NAVIGATION ============================= */
    #sidebar {
      background: var(--secondary);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
      transition: background var(--transition-speed), color var(--transition-speed);
      height: max-content;
    }
    #sidebar a {
      display: block;
      padding: 10px;
      border-radius: 8px;
      color: var(--text);
      transition: background 0.2s;
      font-weight: 500;
      text-decoration: none;
    }
    #sidebar a:hover {
      background: var(--border);
      color: var(--text);
    }

    /* ============================= MAIN CONTENT & RIGHT SIDEBAR ============================= */
    #mainContent, 
    #rightSide {
      background: var(--secondary);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      transition: background var(--transition-speed), color var(--transition-speed);
    }

    /* ============================= SEARCH SECTION ============================= */
    #searchSection {
      margin-bottom: 20px;
    }
    #searchSection label {
      font-weight: 600;
      margin-bottom: 8px;
      display: block;
    }
    #searchInput {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 20px;
      margin-bottom: 10px;
      font-size: 1rem;
      background: var(--bg);
      color: var(--text);
      text-align: center;
    }
    #searchBtn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 16px;
      font-weight: 600;
      border-radius: 20px;
      width: 100%;
    }
    #searchBtn:hover {
      background: #1387c7;
    }

    /* ============================= PANELS ============================= */
    .panel {
      background: var(--bg);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      transition: background var(--transition-speed), color var(--transition-speed);
    }
    .panel h2, .panel h3 {
      padding-bottom: 10px;
    }
    .panel input, .panel textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 1rem;
      background: var(--secondary);
      color: var(--text);
      transition: background var(--transition-speed), color var(--transition-speed);
    }
    .panel button {
      height: 40px;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 17px;
      font-weight: 600;
      border-radius: 17px;
      cursor: pointer;
      transition: background 0.2s;
      margin-top: 10px;
    }
    .panel button:hover {
      background: #1387c7;
    }

    /* ============================= SETTINGS UPDATE ROWS ============================= */
    .updateRow {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .updateRow label {
      min-width: 120px;
      font-weight: 500;
    }
    .updateRow input, .updateRow textarea {
      width: 70%;
    }
    .updateRow button {
      margin-top: 0;
    }

    /* ============================= MESSAGE BOX ============================= */
    #messageBox {
      position: relative;
      display: none;
      text-align: center;
      padding: 15px 20px;
      border-radius: 15px;
      color: #fff;
      font-weight: 600;
      z-index: 1000;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      align-items: center;
      margin-bottom: 20px;
    }
    #messageCloseBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #fff;
      color: #000;
      padding: 5px 10px;
      border-radius: 50%;
      font-size: 15px;
      font-weight: bold;
    }

    /* ============================= POST ITEMS ============================= */
    .postItem {
      background: var(--secondary);
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
      border: 1px solid var(--border);
      cursor: pointer;
      transition: background 0.2s, transform 0.2s, border 0.2s;
    }
    .postItem:hover {
      background: var(--bg);
      transform: translateY(-2px);
    }
    .postHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    .authorInfo {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .authorDetails {
      display: flex;
      flex-direction: column;
    }
    .authorName {
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent);
    }
    .postDate {
      font-size: 0.75rem;
      color: var(--text);
      opacity: 0.7;
    }
    .postText {
      margin: 7px 0;
      padding: 7px;
      font-size: 0.95rem;
    }
    .statsLine {
      font-size: 0.9rem;
      opacity: 0.75;
      margin-top: 8px;
    }

    .reactionRow {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .reactionRow a:hover {
      text-decoration: none;
    }
    .reactionBtn {
      cursor: pointer;
      padding: 6px 10px;
      border-radius: 20px;
      background: var(--bg);
      border: 1px solid var(--border);
      transition: background 0.2s;
      font-size: 0.9rem;
      text-align: center;
    }
    .reactionBtn:hover {
      background: var(--secondary);
    }

    /* Post Options (edit/hide/pin, etc.) */
    .postOptions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .postOptions button, .postHiddenMessage button, .activityItem button, .genBtn {
      height: auto !important;
      background: var(--accent);
      color: #fff;
      border-radius: 20px;
      padding: 5px 15px !important;
      font-size: 0.85rem;
    }
    .postHiddenMessage button {
      margin-top: 10px;
    }
    .postOptions button:hover {
      background: #1387c7;
    }
    .postHiddenMessage button:hover {
      background: #1387c7;
    }
    .readMore {
      font-weight: bold;
    }

    /* ============================= COMMENT BOX ============================= */
    #commentBox {

    }
    #commentText {
      flex: 1;
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px;
      background: var(--secondary);
      color: var(--text);
    }

    /* Make the comments panel scrollable for infinite loading */
    /* You can remove these if you want full-page scroll for comments: 
    #commentsPanel {
      overflow-y: auto; 
      max-height: 50vh;
    }
    */

    /* ============================= FALLBACKS & AVATARS ============================= */
    #myProfileAvatar {
      background: var(--border);
    }
    .coverFallback {
      background: var(--border);
      width: 100%;
      height: 220px;
      border-radius: 12px;
    }
    .avatarContainer img, .avatarContainer .avatarFallback {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .avatarFallback {
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--border);
      color: #fff;
      font-weight: 700;
      font-size: 1.9rem;
      width: 40px;
      height: 40px;
      border-radius: 50%;
    }
    .postAvatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      object-fit: cover;
      border: 1px solid var(--border);
      background: var(--border);
    }

    /* ============================= PROFILE HEADER ============================= */
    #profileHeader {
      background: var(--bg);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .coverContainer {
      position: relative;
    }
    #coverPhoto, #myCoverPhoto {
      width: 100%;
      height: 220px;
      object-fit: cover;
      border-radius: 12px;
    }
    .avatarContainer {
      position: absolute;
      bottom: -50px;
      left: 20px;
      width: 100px;
      height: 100px;
      border: 3px solid var(--bg);
      border-radius: 50%;
      overflow: hidden;
      background: var(--border);
    }
    #nicknameLine, #myNicknameLine {
      margin-top: 55px;
      margin-bottom: 5px;
      padding-bottom: 0;
      font-size: 1.3rem;
      font-weight: 700;
    }
    #usernameLine, #bioLine, #locationLine, #websiteLine, #joinedDate,
    #myUsernameLine, #myBioLine, #myLocationLine, #myWebsiteLine, #myStats {
      color: var(--text);
      margin-top: 7px;
      font-size: 0.95rem;
      opacity: 0.9;
    }
    #bioLine, #myBioLine {
      padding-bottom: 0;
    }
    #followBtn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 8px 14px;
      font-weight: 600;
      border-radius: 20px;
      margin-top: 12px;
    }
    #followBtn:hover {
      background: #1387c7;
    }
    #followerStats {
      margin-top: 8px;
      font-size: 0.95rem;
      opacity: 0.8;
    }

    /* ============================= CREATE POST PANEL ============================= */
    #createPostPanel textarea {
      background: var(--secondary);
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 12px;
    }

    /* ============================= PINNED POST ============================= */
    #userPinnedPanel, #myPinnedPostPanel {
      display: none;
      margin-bottom: 20px;
    }

    /* ============================= PROFILE TABS ============================= */
    .profileTabs {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      border-bottom: 2px solid var(--border);
    }
    .profileTabs button {
      flex: 1;
      padding: 10px;
      background: none;
      color: var(--text);
      cursor: pointer;
      border: none;
      transition: background 0.2s;
      font-size: 15px;
    }
    .profileTabs button:hover {
      background: var(--secondary);
    }
    .profileTabs button.activeTab {
      color: var(--accent);
      border-bottom: 3px solid var(--accent);
      font-weight: 600;
    }
    .shareProfileButton {
      height: auto;
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 5px 10px;
      border-radius: 7px;
      cursor: pointer;
      font-weight: 600;
    }

    /* ============================= ROUTE PAGES ============================= */
    .routePage {
      display: none;
    }
    #editPostPage, #editCommentPage, #repostPage {
      padding: 20px;
    }
    #editPostPage textarea, #editCommentPage textarea, #repostPage textarea {
      width: 100%;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 1rem;
      background: var(--secondary);
      color: var(--text);
    }

    /* ============================= QUOTED / REPOSTED FRAME ============================= */
    .quotedFrame {
      border-left: 4px solid var(--accent);
      margin: 10px 0 15px 0;
      padding: 10px;
      background: var(--secondary);
    }
    .repostBlock p {
      padding-bottom: 5px;
    }

    /* ============================= SHARE MODAL ============================= */
    #shareModal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #shareModal .modal-overlay {
      position: absolute;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
    }
    #shareModal .modal-content {
      position: relative;
      background: var(--bg);
      padding: 10px 20px 20px;
      border-radius: 8px;
      z-index: 10001;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 220px;
      border: 1px solid var(--border);
    }
    #shareModal .modal-content h3 {
      margin-bottom: 10px;
      font-size: 1rem;
      color: var(--accent);
    }
    #shareModal .modal-content button {
      margin: 5px 0;
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.2s;
    }
    #shareModal .modal-content button:hover {
      background: #1387c7;
    }
    #shareModal .close-modal {
      position: absolute;
      top: 5px; right: 5px;
      border: none; 
      cursor: pointer;
      font-size: 17px;
      background: none !important;
      color: var(--danger) !important;
      font-weight: bold;
    }
    #shareModal .close-modal:hover {
      color: var(--accent);
    }
    .share-buttons {
      display: grid;
    }

    /* ============================= REACTION HIGHLIGHT ============================= */
    .highlight {
      background: var(--accent) !important;
    }

    /* ============================= ADDITIONAL CLASSES ============================= */
    .activityItem {
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--secondary);
    }
    .activityItem:hover {
      background: var(--bg);
      transform: translateY(-2px);
    }
    .activityItem p {
      padding-top: 5px;
      padding-bottom: 5px;
    }
    .postHiddenMessage {
      background: var(--secondary);
      padding: 10px;
      font-style: italic;
      opacity: 0.8;
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-top: 10px;
    }
    .recentUser, .officialUser {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .recentUser a, .officialUser a {
      display:flex;
      align-items:center;
      gap:10px;
      text-decoration:none;
      color:inherit;
    }
    .resources-section {
      display: grid;
      gap: 20px;
    }
    .resources-section h3 {
      grid-column: 1 / -1;
    }
    .resource-category {
      
    }
    .resource-category h3, #recentlyJoinedPanel h3, #statsPanel h3 {
      color: var(--accent);
      font-weight: 600;
    }
    #statsPanel strong {
       font-weight: 600;
     }
    .resource-category a {
      padding: 2px 8px;
      border-radius: 5px;
      text-decoration: none;
      color: var(--text);
      transition: background 0.2s, transform 0.2s;
      text-align: center;
      margin: 0 3px;
      line-break: auto;
    }
    .resource-category a:hover {
      background: var(--accent);
      color: #fff;
      transform: translateY(-1px);
      border-radius: 15px;
    }

    /* Make user/my comments scrollable for infinite load: */
    #userCommentsFeed,
    #myCommentsFeed {
      max-height: 450px;
      overflow-y: auto;
    }

    /* ============================= FOOTER ============================= */
    footer {
      position: fixed;
      bottom: 0; left: 0;
      width: 100%;
      background: var(--secondary);
      color: var(--text);
      text-align: center;
      padding: 10px;
      font-size: 0.9rem;
      z-index: 99;
      transition: background var(--transition-speed), color var(--transition-speed);
    }
    @media (max-width: 768px) {
      footer {
        position: static;
      }
    }
  </style>  
</head>
<body>
  <!-- Loader Overlay -->
  <div id="loader">
    <div class="spinner"></div>
  </div>

  <!-- Top Bar -->
  <div id="topBar">
    <h1>Zether - Decentralized Social Platform</h1>

    <!-- Theme Toggle -->
    <div class="themeToggle">
      <label for="themeSelector"><strong>Theme:</strong></label>
      <select id="themeSelector">
        <option value="light">Light</option>
        <option value="dim">Dim</option>
        <option value="dark">Dark</option>
      </select>
    </div>

    <div class="connectSection">
      <button id="connectBtn">Connect Wallet</button>
      <span id="walletAddr"></span>
      <button id="logoutBtn" style="display:none;">Logout</button>
    </div>
  </div>

  <div id="layout">
      
    <!-- Sidebar Navigation -->
    <div id="sidebar">
      <div class="navMenuDiv">
        <a href="#home"><i class="fas fa-home" style="padding-right: 5px;"></i>Home</a>
        <a href="#profile"><i class="fas fa-user" style="padding-right: 5px;"></i>My Profile</a>
        <a href="#settings"><i class="fas fa-gear" style="padding-right: 5px;"></i>Settings</a>
        <a href="faq"><i class="fas fa-circle-question" style="padding-right: 5px;"></i>FAQ</a>
        <a href="https://zether.org/faucet" target="_blank"><i class="fas fa-faucet-drip" style="padding-right: 5px;"></i>Faucet</a>
        <a href="https://zether.org/" target="_blank"><i class="fas fa-circle-info" style="padding-right: 5px;"></i>Zether</a>
      </div>
      <div class="adsDiv">
        <!-- Ads go here -->
      </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent">
      <!-- Message Box -->
      <div id="messageBox">
        <button id="messageCloseBtn">X</button>
        <span id="messageText"></span>
      </div>

      <!-- Home Route -->
      <div class="routePage" id="homePage">
        <div class="panel">
          <h2>Recent Posts</h2>
          <div id="homeFeed"></div>
        </div>
      </div>

      <!-- Single Post Route -->
      <div class="routePage" id="postPage">
        <div class="panel" id="postPanel"></div>
        <div class="panel" id="commentFormPanel">
          <h3>Write a Comment</h3>
          <div id="commentBox">
            <textarea id="commentText" rows="5" placeholder="Your comment..."></textarea>
            <button id="commentBtn">Comment</button>
          </div>
        </div>
        <div class="panel" id="commentsPanel">
          <!-- Comments go here -->
        </div>
      </div>

      <!-- Public User Profile -->
      <div class="routePage" id="userProfilePage">
        <div id="profileHeader">
          <div class="coverContainer">
            <div id="coverFallback" class="coverFallback" style="display:none;"></div>
            <img id="coverPhoto" src="" alt="Cover" style="display:none;" />
            <div class="avatarContainer">
              <div id="avatarFallback" class="avatarFallback" style="display:none;"></div>
              <img id="profileAvatar" src="" alt="Avatar" style="display:none;" />
            </div>
          </div>
          <div class="postHeader" style="margin-top: 10px;">
            <div class="authorInfo">
              <div class="authorDetails">
                <span id="nicknameLine" class="authorName"></span>
                <div id="usernameLine"></div>
                <div id="postDate" class="postDate"></div>
              </div>
            </div>
          </div>
          <p id="bioLine"></p>
          <div style="display: flex; align-items: center; gap: 15px; margin: 5px 0;">
            <p id="locationLine"></p>
            <p id="websiteLine"></p>
          </div>
          <p id="followerStats"></p>
          <p id="joinedDate"></p>
          <button id="followBtn" style="display:none;"></button>
        </div>
        <div id="userPinnedPanel" class="panel" style="display:none;">
          <h3>Pinned Post <i class="fas fa-thumbtack"></i></h3>
          <div id="userPinnedContent"></div>
        </div>
        <!-- Profile Tabs -->
        <div class="profileTabs" id="profileTabs">
          <button id="profilePostsTab" class="activeTab" onclick="showUserPosts()">Posts</button>
          <button id="profileCommentsTab" onclick="showUserComments()">Comments</button>
        </div>
        <!-- We remove the scroll style on these sections, so we can use window.onscroll just like My Profile -->
        <div id="profilePostsSection">
          <div id="userFeed"></div>
        </div>
        <div id="profileCommentsSection" style="display: none;">
          <div id="userCommentsFeed"></div>
        </div>
      </div>

      <!-- My Profile -->
      <div class="routePage" id="myProfilePage">
        <div id="myProfileHeader"></div>
        <!-- Create Post Panel -->
        <div id="createPostPanel" class="panel">
          <h3>Create a Post</h3>
          <textarea id="postContent" rows="5" placeholder="What's happening?"></textarea>
          <button id="createPostBtn">Post</button>
        </div>
        <!-- Pinned Post Panel for My Profile -->
        <div id="myPinnedPostPanel" class="panel" style="display: none;">
          <h3>Pinned Post <i class="fas fa-thumbtack"></i></h3>
          <div id="myPinnedPostContent"></div>
        </div>
        <!-- My Profile Tabs -->
        <div class="profileTabs" id="myProfileTabs">
          <button id="myProfilePostsTab" class="activeTab" onclick="showMyPosts()">Posts</button>
          <button id="myProfileCommentsTab" onclick="showMyComments()">Comments</button>
        </div>
        <div id="myProfilePostsSection">
          <div id="myPostsFeed"></div>
        </div>
        <div id="myProfileCommentsSection" style="display: none;">
          <div id="myCommentsFeed"></div>
        </div>
      </div>

      <!-- Settings -->
      <div class="routePage" id="settingsPage">
        <div class="panel" id="accountPanel">
          <h2>Account</h2>
          <p id="accountStatus">[Checking...]</p>
        </div>
        <div class="panel" id="profileUpdatesPanel">
          <h2>Profile Updates</h2>
          <div class="updateRow">
            <label for="setNickname">Nickname</label>
            <input type="text" id="setNickname" />
            <button id="updateNicknameBtn">Update</button>
          </div>
          <div class="updateRow">
            <label for="setAbout">About</label>
            <textarea id="setAbout" rows="3"></textarea>
            <button id="updateAboutBtn">Update</button>
          </div>
          <div class="updateRow">
            <label for="setWebsite">Website <i class="fas fa-globe"></i></label>
            <input type="text" id="setWebsite" />
            <button id="updateWebsiteBtn">Update</button>
          </div>
          <div class="updateRow">
            <label for="setLocation">Location</label>
            <input type="text" id="setLocation" />
            <button id="updateLocationBtn">Update</button>
          </div>
          <div class="updateRow">
            <label for="setProfilePicture">Profile Pic (URL)</label>
            <input type="text" id="setProfilePicture" />
            <button id="updateProfilePictureBtn">Update</button>
          </div>
          <div class="updateRow">
            <label for="setCoverPicture">Cover Pic (URL)</label>
            <input type="text" id="setCoverPicture" />
            <button id="updateCoverPictureBtn">Update</button>
          </div>
          <div class="updateRow" style="margin-top: 50px;">
            <label for="setUsername">Username</label>
            <input type="text" id="setUsername" />
            <button id="updateUsernameBtn" style="background: var(--danger);">Change</button>
          </div>
        </div>
      </div>

      <!-- Edit Post Page -->
      <div class="routePage" id="editPostPage">
        <div class="panel">
          <h3>Edit Post</h3>
          <textarea id="editPostContent" rows="5" placeholder="Edit your post..."></textarea>
          <div id="originalPostQuote" class="quotedFrame" style="display:none;"></div>
          <button id="saveEditPostBtn" style="margin-right: 10px;">Save</button>
          <button id="cancelEditPostBtn">Cancel</button>
        </div>
      </div>

      <!-- Edit Comment Page -->
      <div class="routePage" id="editCommentPage">
        <div class="panel">
          <h3>Edit Comment</h3>
          <textarea id="editCommentContent" rows="5" placeholder="Edit your comment..."></textarea>
          <button id="saveEditCommentBtn" style="margin-right: 10px;">Save</button>
          <button id="cancelEditCommentBtn">Cancel</button>
        </div>
      </div>

      <!-- Repost Page -->
      <div class="routePage" id="repostPage">
        <div class="panel">
          <h3>Repost</h3>
          <textarea id="repostContent" rows="5" placeholder="Add a comment (optional)"></textarea>
          <div id="originalPostFrame" class="quotedFrame" style="margin-bottom:10px;"></div>
          <button id="submitRepostBtn">Repost</button>
        </div>
      </div>
    </div>

    <!-- Right Sidebar -->
    <div id="rightSide">
      <div id="searchSection">
        <input type="text" id="searchInput" placeholder="e.g. post123 or zether" />
        <button id="searchBtn">Search</button>
      </div>
      <div class="panel resources-section" style="margin-bottom: 20px;">
        <div class="resource-category">
          <h3>Official Profiles</h3>
          <div class="officialUser">
            <a href="#zether">
              <img class="postAvatar" src="https://zether.org/img/logo.png" alt="Zether" onerror="this.onerror=null;this.style.display='none';">
              <span>Zether (@zether)</span>
            </a>
          </div>
        </div>
      </div>
      <div id="recentlyJoinedPanel" class="panel">
        <h3>Recently Joined</h3>
        <div id="recentlyJoinedContent"></div>
      </div>
      <div id="statsPanel" class="panel">
        <h3>Platform Stats</h3>
        <div id="statsContent"></div>
      </div>
    </div>
    
  </div>

  <!-- Footer -->
  <footer>
    © 2025 Zether. Crafted and developed by Zether. All rights reserved.
  </footer>

  <!-- External Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.8.2/dist/web3.min.js"></script>
  <script src="abi.js"></script>

  <!-- ================== ENGINE SCRIPT ================== -->
  <script>
    /* =================== Helper Functions =================== */
    function safeAddEventListener(id, event, handler) {
      const el = document.getElementById(id);
      if (el) { el.addEventListener(event, handler); }
    }
    
    function refreshPage() {
      window.location.reload();
    }
    
    function goBack() {
      window.history.back();
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    document.getElementById("cancelEditPostBtn").addEventListener("click", goBack);
    document.getElementById("cancelEditCommentBtn").addEventListener("click", goBack);
    
    function getAvatarHTML(author) {
      if (author.profilePic && author.profilePic.trim() !== "") {
        return `<img class="postAvatar" src="${author.profilePic}" alt="Avatar" onerror="this.onerror=null;this.style.display='none';" />`;
      } else {
        // Fallback with 1-letter initial
        const c = author.displayName ? author.displayName.charAt(0).toUpperCase() : '?';
        return `<div class="avatarFallback">${c}</div>`;
      }
    }

    function formatMarkdown(text) {
      // Replace @mentions in the raw text.
      text = text.replace(/(^|\s)@([A-Za-z0-9_]+)/g, function(match, preceding, username) {
        return preceding + '<a href="#' + username + '">@' + username + '</a>';
      });
      let html = marked.parse(text || "");
      html = html.replace(/<a /g, '<a target="_blank" ');
      return html;
    }

    function showLoader() { document.getElementById('loader').style.display = 'flex'; }
    function hideLoader() { document.getElementById('loader').style.display = 'none'; }
    function formatTimestamp(ts) { return new Date(ts * 1000).toLocaleString('en-GB'); }
    function formatTimestampZ(ts) { return new Date(ts * 1000).toLocaleDateString('en-US', { month: 'long', year: 'numeric' }); }
    function shortAddress(addr) { return addr ? addr.slice(0,6) + "..." + addr.slice(-4) : ""; }
    
    function showMessage(msg, isError) {
      const box = document.getElementById("messageBox");
      box.style.backgroundColor = isError ? "var(--danger)" : "var(--success)";
      document.getElementById("messageText").textContent = msg;
      box.style.display = "block";
    }
    function hideMessage() { document.getElementById("messageBox").style.display = "none"; }

    /* =================== Configuration Constants =================== */
    const CONTRACT_ADDRESS = "0xCF7cD887E1a6f39D2389cE4a961aAFe26A10B0a1";
    const ZETHER_CHAIN = {
      chainId: "0xAE97B",
      chainName: "Zether Mainnet",
      nativeCurrency: { name: "ZTH", symbol: "ZTH", decimals: 18 },
      rpcUrls: ["https://rpc.zether.org/"],
      blockExplorerUrls: ["https://zthscan.com/"]
    };

    const rpcUrl = "https://rpc.zether.org/";

    /* =================== Contract ABIs (from abi.js) =================== */
    // Use the global: const CONTRACT_ABI

    /* =================== Global Variables =================== */
    let readOnlyWeb3;
    let readOnlyContract;
    let userWeb3, userContract;
    let userAccount = null;
    let isRegistered = false;

    // For Home Feed infinite scroll
    let homeLastId = 0;      
    let homeHasMore = true;
    let homeLoading = false;

    // For single post:
    let currentPostId = 0;

    // For post comments infinite scroll
    const commentLastId = {};     // postId -> last commentId not yet loaded
    const commentsLoading = {};   // postId -> boolean

    // Track duplicates to prevent double-rendering:
    let loadedPostIdsHome = new Set();     // For the home feed
    let loadedMyPostIds = new Set();       // For "my posts"
    let loadedUserPostIds = new Set();     // For a public user's posts
    let loadedComments = {};               // postId -> Set of commentIds already rendered

    // For user profile we store the current target user
    let currentUsername = "";
    let currentProfileUserAddr = null;

    // For user profile posts infinite scroll
    let userLastPost = 0; 
    let userHasMorePosts = true;
    let userLoadingPosts = false;

    // For user profile comments infinite scroll
    let userLastComment = 0;
    let userHasMoreComments = true;
    let userLoadingComments = false;

    // For my profile:
    let myLastPost = 0;
    let myHasMorePosts = true;
    let myLoadingPosts = false;

    let myLastComment = 0;
    let myHasMoreComments = true;
    let myLoadingComments = false;

    // For caching user info
    const userProfileCache = {};

    // Global variable to store a target comment id (if any)
    let currentTargetCommentId = null;

    /* =================== onload =================== */
    window.addEventListener('DOMContentLoaded', async () => {
      initUI();
      initReadOnlyWeb3();
      hideLoader();

      if (window.ethereum) {
        try {
          const accts = await window.ethereum.request({ method: 'eth_accounts' });
          if (accts.length > 0) {
            userAccount = accts[0];
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            if (chainId.toLowerCase() !== ZETHER_CHAIN.chainId.toLowerCase()) await trySwitchChain();
            await initUserWeb3();
            document.getElementById("connectBtn").style.display = "none";
            document.getElementById("walletAddr").textContent = shortAddress(userAccount);
            await checkRegistration();
            document.getElementById("logoutBtn").style.display = "inline-block";
            if (isRegistered) loadPinnedPost();
          }
        } catch(e) { console.log("Auto-connect error:", e); }
      }

      loadRecentlyJoined();
      loadPlatformStats();
      window.addEventListener('hashchange', handleRouting);
      handleRouting();
      initTheme();
      
      // Auto-reload home feed every 60 seconds if still on home page
      if (window.location.hash === "" || window.location.hash === "#home") {
        setInterval(() => {
          if (window.location.hash === "" || window.location.hash === "#home") {
            loadHomeFeedInitial();
          }
        }, 60000); // 60000ms = 60 seconds
      }
    });

    /* =================== UI Initialization =================== */
    function initUI() {
      safeAddEventListener("messageCloseBtn", "click", hideMessage);
      safeAddEventListener("connectBtn", "click", connectWallet);
      safeAddEventListener("commentBtn", "click", createCommentOnPost);
      safeAddEventListener("createPostBtn", "click", createNewPost);
      safeAddEventListener("updateUsernameBtn", "click", updateUsername);
      safeAddEventListener("updateNicknameBtn", "click", updateNickname);
      safeAddEventListener("updateAboutBtn", "click", updateAbout);
      safeAddEventListener("updateWebsiteBtn", "click", updateWebsite);
      safeAddEventListener("updateLocationBtn", "click", updateLocation);
      safeAddEventListener("updateProfilePictureBtn", "click", updateProfilePicture);
      safeAddEventListener("updateCoverPictureBtn", "click", updateCoverPicture);
      safeAddEventListener("searchBtn", "click", doSearch);

      safeAddEventListener("logoutBtn", "click", () => {
        userAccount = null; 
        isRegistered = false;
        document.getElementById("walletAddr").textContent = "";
        document.getElementById("logoutBtn").style.display = "none";
        document.getElementById("connectBtn").style.display = "inline-block";
        showMessage("Logged out.", false);
      });
    }

    /* =================== Search =================== */
    function doSearch() {
      const val = document.getElementById("searchInput").value.trim();
      if (!val) return;
      if (val.toLowerCase().startsWith("post")) {
        const num = val.replace(/[^0-9]/g,"");
        window.location.hash = "post" + num;
      } else {
        window.location.hash = val;
      }
    }

    /* =================== Routing =================== */
    function handleRouting() {
      // Clear any global scroll listeners so we don’t double-invoke
      window.onscroll = null;
      document.getElementById("commentsPanel")?.removeEventListener("scroll", handleCommentsWindowScroll);
      document.getElementById("userCommentsFeed")?.removeEventListener("scroll", userCommentsScrollHandler);
      document.getElementById("myCommentsFeed")?.removeEventListener("scroll", myCommentsScrollHandler);

      // Hide all route pages
      document.querySelectorAll(".routePage").forEach(r => r.style.display = "none");

      const rawHash = window.location.hash;
      const deepLinkRegex = /^#post(\d+)(?:\/#comment(\d+))?$/;
      const match = rawHash.match(deepLinkRegex);

      if (match) {
        // #post123 or #post123/#comment456
        const postId = match[1];
        const commentId = match[2];
        document.getElementById("postPage").style.display = "block";
        loadSinglePost(postId, commentId);
        return;
      }

      const hash = rawHash.replace("#", "");
      if (!hash || hash === "home") {
        document.getElementById("homePage").style.display = "block";
        loadHomeFeedInitial();
      }
      else if (hash.startsWith("editpost-")) {
        document.getElementById("editPostPage").style.display = "block";
        const postId = hash.split("-")[1];
        loadEditPost(postId);
      }
      else if (hash.startsWith("editcomment-")) {
        document.getElementById("editCommentPage").style.display = "block";
        const parts = hash.split("-");
        loadEditComment(parts[1], parts[2]);
      }
      else if (hash.startsWith("repost-")) {
        document.getElementById("repostPage").style.display = "block";
        const postId = hash.split("-")[1];
        loadRepost(postId);
      }
      else if (hash === "profile") {
        document.getElementById("myProfilePage").style.display = "block";
        loadMyProfile();
      }
      else if (hash === "settings") {
        document.getElementById("settingsPage").style.display = "block";
        loadSettings();
      }
      else if (hash.startsWith("post")) {
        // e.g. #post123
        document.getElementById("postPage").style.display = "block";
        const postId = hash.replace("post", "");
        loadSinglePost(postId);
      }
      else {
        // If none of the above, treat as a user profile route, e.g. #Alice
        document.getElementById("userProfilePage").style.display = "block";
        loadUserProfile(hash);
      }
    }

    /* =================== Wallet & Contract Initialization =================== */
    async function connectWallet() {
      if (!window.ethereum) return showMessage("No Web3 wallet found. Install MetaMask.", true);
      try {
        const accts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        if (accts.length > 0) {
          userAccount = accts[0];
          const chainId = await window.ethereum.request({ method: 'eth_chainId' });
          if (chainId.toLowerCase() !== ZETHER_CHAIN.chainId.toLowerCase()) await trySwitchChain();
          await initUserWeb3();
          document.getElementById("connectBtn").style.display = "none";
          document.getElementById("walletAddr").textContent = shortAddress(userAccount);
          await checkRegistration();
          showMessage("Wallet connected!", false);
          refreshPage();
          document.getElementById("logoutBtn").style.display = "inline-block";
        }
      } catch(e) {
        showMessage("Connect error: " + e.message, true);
      }
    }
    function initReadOnlyWeb3() {
      readOnlyWeb3 = new Web3(new Web3.providers.HttpProvider(rpcUrl));
      readOnlyContract = new readOnlyWeb3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
    }
    async function initUserWeb3() {
      userWeb3 = new Web3(window.ethereum);
      userContract = new userWeb3.eth.Contract(CONTRACT_ABI, CONTRACT_ADDRESS);
    }
    async function trySwitchChain() {
      try {
        await window.ethereum.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: ZETHER_CHAIN.chainId }]
        });
      } catch(e) {
        if (e.code === 4902) {
          try {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [ZETHER_CHAIN]
            });
          } catch(err) { console.log("Add chain error:", err); }
        } else { console.log("Switch chain error:", e); }
      }
    }
    async function checkRegistration() {
      if (!userWeb3 || !userAccount) return;
      try {
        isRegistered = await readOnlyContract.methods.isUserRegistered(userAccount).call();
      } catch(e) { isRegistered = false; }
    }
    
    // Helper: Recursively traverse HTML nodes and build truncated HTML without breaking words.
    function truncateHTML(html, maxChars) {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = html;
      let currentCount = 0;
      let reachedLimit = false;
  
      function traverse(node) {
        if (reachedLimit) return "";
    
        let result = "";
    
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          if (currentCount + text.length <= maxChars) {
            currentCount += text.length;
            return text;
          } else {
            // Take as much text as possible without breaking a word.
            const remaining = maxChars - currentCount;
            let subText = text.substring(0, remaining);
            const lastSpace = subText.lastIndexOf(" ");
            if (lastSpace !== -1) {
              subText = subText.substring(0, lastSpace);
            }
            currentCount = maxChars;
            reachedLimit = true;
            return subText + "...";
          }
        } else if (node.nodeType === Node.ELEMENT_NODE) {
          // Special handling for <br>: do not add a closing tag.
          if (node.nodeName.toLowerCase() === "br") {
            return "<br>";
          }
          
          // Rebuild the element's opening tag with attributes.
          let openTag = `<${node.nodeName.toLowerCase()}`;
          for (let attr of node.attributes) {
            openTag += ` ${attr.name}="${attr.value}"`;
          }
          openTag += ">";
      
          // Process children.
          let innerHTML = "";
          for (let i = 0; i < node.childNodes.length; i++) {
            innerHTML += traverse(node.childNodes[i]);
            if (reachedLimit) break;
          }
      
          const closeTag = `</${node.nodeName.toLowerCase()}>`;
          return openTag + innerHTML + closeTag;
        }
        return "";
      }
  
      return traverse(tempDiv);
    }

    // Main function using the above helper.
    function getTruncatedContent(postId, rawContent) {
      // Convert raw markdown to HTML.
      const formattedContent = formatMarkdown(rawContent);
  
      // Set maximum allowed characters.
      const maxChars = 300; // adjust as needed
  
      // Create a temporary element to get the plain text.
      const tempEl = document.createElement("div");
      tempEl.innerHTML = formattedContent;
      const plainText = tempEl.textContent || tempEl.innerText || "";
  
      let isTruncated = plainText.length > maxChars;
      let truncatedHTML = formattedContent;
      if (isTruncated) {
        truncatedHTML = truncateHTML(formattedContent, maxChars);
      }
  
      let outputHTML = `<div>${truncatedHTML}</div>`;
      if (isTruncated) {
        outputHTML += `<br><a href="#post${postId}" class="readMore" onclick="event.stopPropagation();">Read more</a>`;
      }
  
      return outputHTML;
    }

    /* =================== Home Feed (Load 5 first, 5 on scroll) =================== */
    async function loadHomeFeedInitial() {
      showLoader();
      
      homeHasMore = true;
      homeLastId = 0;
      loadedPostIdsHome.clear(); // reset the set
      document.getElementById("homeFeed").innerHTML = "";

      try {
        const total = parseInt(await readOnlyContract.methods.getGlobalPostCount().call(),10);
        if (total === 0) {
          document.getElementById("homeFeed").innerHTML = "<p>No posts yet.</p>";
          homeHasMore = false;
          return;
        }
        homeLastId = total;
        // First load => 5
        await loadMoreHomePosts(5);

        // On window scroll => load 5
        window.onscroll = async function() {
          if (!homeHasMore || homeLoading) return;
          if (window.innerHeight + window.pageYOffset >= document.body.offsetHeight - 50) {
            homeLoading = true;
            await loadMoreHomePosts(5); 
            homeLoading = false;
          }
        };
        
        hideLoader();
      } catch(e) {
        console.log("Error loadHomeFeedInitial:", e);
      }
    }
    async function loadMoreHomePosts(batchSize) {
      if (!homeHasMore || homeLastId < 1) return;
      const feed = document.getElementById("homeFeed");

      let start = homeLastId;
      let end = start - batchSize + 1;
      if (end < 1) end = 1;

      for (let i = start; i >= end; i--) {
        try {
          const post = await readOnlyContract.methods.getPost(i).call();
          if (!post[0] || post[11]) continue; // skip hidden or missing
          // If already appended, skip
          if (loadedPostIdsHome.has(post[0])) continue;
          loadedPostIdsHome.add(post[0]);
          await appendPostToFeed(feed, post);
        } catch(e) {
          console.log("Error loading post #", i, e);
        }
      }
      homeLastId = end - 1;
      if (homeLastId < 1) {
        homeHasMore = false;
      }
    }

    /* =================== Single Post & Comments =================== */
    async function loadSinglePost(postId, targetCommentId = null) {
      showLoader();
      
      currentPostId = postId;
      document.getElementById("postPanel").innerHTML = "<p>Loading post...</p>";
      
      // Clear out old comments
      const commentsPanel = document.getElementById("commentsPanel");
      commentsPanel.innerHTML = "";
      loadedComments[postId] = new Set();

      try {
        const post = await readOnlyContract.methods.getPost(postId).call();
        if (!post[0]) {
          document.getElementById("postPanel").innerHTML = "<p>Post not found.</p>";
          hideLoader();
          return;
        }
        if (post[11]) {
          document.getElementById("postPanel").innerHTML = "<p>Post is hidden.</p>";
          hideLoader();
          return;
        }

        // Render post
        const authorDisplay = await getUserDisplayName(post[1]);
        let postContentHTML = post[8] ? await renderRepost(post) : formatMarkdown(post[7]);

        let pinOptions = "";
        if (userAccount && userAccount.toLowerCase() === post[1].toLowerCase() && !post[11]) {
          if (postId == window.pinnedPostId) {
            pinOptions = `<span class="reactionBtn" title="Unpin" onclick="unpinMyPost(); event.stopPropagation();"><i class="fas fa-thumbtack-slash"></i></span>`;
          } else {
            pinOptions = `<span class="reactionBtn" title="Pin" onclick="pinMyPost(${postId}); event.stopPropagation();"><i class="fas fa-thumbtack"></i></span>`;
          }
        }
        const ownerEditHide = (userAccount && userAccount.toLowerCase() === post[1].toLowerCase())
          ? `
            <a class="reactionBtn edit" title="Edit" href="#editpost-${post[0]}"><i class="fas fa-pen"></i></a>
            <span class="reactionBtn hide" title="Hide" onclick="toggleHidePost(${post[0]}, true); event.stopPropagation();"><i class="fas fa-eye"></i>️</span>
            ${pinOptions}
          `
          : "";

        document.getElementById("postPanel").innerHTML = `
          <h3>Post #${postId}</h3>
          <div class="postItem" style="cursor:auto;" id="post-${postId}">
            <div class="postHeader">
              <div class="authorInfo">
                ${getAvatarHTML(authorDisplay)}
                <div class="authorDetails">
                  <a href="#${authorDisplay.usernameOnly}"><span class="authorName">${authorDisplay.displayName}</span></a>
                  <div class="postDate">${formatTimestamp(post[3])}</div>
                </div>
              </div>
              <div class="reactionRow">
                <span class="reactionBtn like" title="Like" onclick="reactToPost(${postId}, 'like')"><i class="fas fa-thumbs-up"></i></span>
                <span class="reactionBtn dislike" title="Dislike" onclick="reactToPost(${postId}, 'dislike')"><i class="fas fa-thumbs-down"></i></span>
                <span class="reactionBtn shareBtn" title="Share" onclick="showShareOptions(${postId}, event)"><i class="fas fa-share"></i></span>
                ${ownerEditHide}
              </div>
            </div>
            <div class="postText"><p>${postContentHTML}</p></div>
            <div class="statsLine">Likes: ${post[5]} | Dislikes: ${post[6]} | Comments: ${post[4]} | Reposts: ${post[10]}</div>
          </div>
        `;
        checkPostReaction(postId, document.querySelector("#postPanel .postItem"));

        // Decide what comments to load
        if (targetCommentId) {
          currentTargetCommentId = targetCommentId;
          // Load ONLY the targeted single comment
          loadOneComment(postId, targetCommentId);
        } else {
          // Reset the target flag when not in single comment mode
          currentTargetCommentId = null;
          loadCommentsInitial(postId);
        }
        
        hideLoader();
      } catch (e) {
        document.getElementById("postPanel").innerHTML = "<p>Post not found.</p>";
        hideLoader();
      }
    }

    // Single targeted comment
    async function loadOneComment(postId, commentId) {
      const commentsPanel = document.getElementById("commentsPanel");
      commentsPanel.innerHTML = "<h3>Comment</h3>";
      
      try {
        const cData = await readOnlyContract.methods.getComment(postId, commentId).call();
        const commentHTML = await buildCommentHTML(postId, cData, true);
        if (!commentHTML) {
          commentsPanel.innerHTML += "<p>Comment not found or hidden.</p>";
          return;
        }
        // Render exactly one comment
        commentsPanel.innerHTML += commentHTML;
        
        const commentEl = document.getElementById("comment-" + commentId);
        if (commentEl) {
          checkCommentReaction(postId, commentId, commentEl);
        }
        
        // Disable infinite scroll in this scenario
        window.removeEventListener("scroll", handleCommentsWindowScroll);
      } catch(e) {
        commentsPanel.innerHTML += "<p>Error loading comment.</p>";
      }
    }

    // Load the initial block of comments
    function loadCommentsInitial(postId) {
      const commentsPanel = document.getElementById("commentsPanel");
      commentsPanel.innerHTML = "<h3>Comments</h3>";

      // Remove any previous scroll listener from window
      window.removeEventListener("scroll", handleCommentsWindowScroll);

      readOnlyContract.methods.getPostCommentCount(postId).call().then(total => {
        const totalComments = parseInt(total, 10);
        if (totalComments <= 0) {
          commentsPanel.innerHTML += "<p>No comments yet.</p>";
          return;
        }

        commentLastId[postId] = totalComments;
        commentsLoading[postId] = false;

        // Load the first batch
        loadMoreComments(postId, 5);

        // Attach scroll to the window only if not in single-comment mode
        if (!currentTargetCommentId) {
          window.addEventListener("scroll", handleCommentsWindowScroll);
        }
      });
    }

    // A single window-based scroll handler
    async function handleCommentsWindowScroll() {
      // NEW: If in single-comment mode, do nothing.
      if (currentTargetCommentId) return;
      const postId = currentPostId;

      // If we’ve no more comments or are mid-loading, skip
      if (!commentLastId[postId] || commentLastId[postId] < 1 || commentsLoading[postId]) return;

      // If user scrolled near the bottom of the entire page
      if (window.innerHeight + window.scrollY >= document.body.scrollHeight - 50) {
        await loadMoreComments(postId, 5);
        commentsLoading[postId] = false;
        window.addEventListener("scroll", handleCommentsWindowScroll);
      }
    }

    // loadMoreComments appends new comments, letting the page grow
    async function loadMoreComments(postId, batchSize) {
      // If already loading comments for this post, exit early.
      if (commentsLoading[postId]) return;
      commentsLoading[postId] = true;

      let last = commentLastId[postId];
      if (!last || last < 1) {
        commentsLoading[postId] = false;
        return;
      }

      const commentsPanel = document.getElementById("commentsPanel");
      const start = last;
      let end = start - batchSize + 1;
      if (end < 1) end = 1;

      for (let i = start; i >= end; i--) {
        if (!loadedComments[postId]) loadedComments[postId] = new Set();
        if (loadedComments[postId].has(i)) continue;

        try {
          const cData = await readOnlyContract.methods.getComment(postId, i).call();
          const html = await buildCommentHTML(postId, cData, false);
          if (html) {
            // Use insertAdjacentHTML to append without overwriting the existing content
            commentsPanel.insertAdjacentHTML('beforeend', html);
            loadedComments[postId].add(i);
          }
        } catch (err) {
          console.log("Comment error on #", i, err);
        }
      }

      commentLastId[postId] = end - 1;
      commentsLoading[postId] = false;
    }

    /* =================== Building comment HTML (clickable) =================== */
    async function buildCommentHTML(postId, cData, highlight = false) {
      // cData = [exists, commentId, text, authorAddr, likes, dislikes, timestamp, hidden]
      
      if (!cData[0]) return "";
  
      // If the comment is hidden…
      if (cData[7]) {
        // If the current user is the comment owner, show an Unhide button.
        if (userAccount && userAccount.toLowerCase() === cData[3].toLowerCase()) {
          return `
            <div class="postItem" id="comment-${cData[1]}" style="border: 1px dashed #ccc; padding: 10px;">
              <div class="postText">
                <p>This comment is hidden.
                  <button onclick="toggleHideComment(${postId}, ${cData[1]}, false); event.stopPropagation();" style="margin-top: 0;" class="genBtn"><i class="fas fa-eye-slash"></i> Unhide Comment</button>
                </p>
              </div>
            </div>
          `;
        } else {
          // For other users hide the comment.
          return "";
        }
      }
  
      // Otherwise, build the full comment HTML.

      const commentId = cData[1];
      const authorAddr = cData[3];
      const authorDisplay = await getUserDisplayName(authorAddr);

      // Entire DIV leads to #postXX/#commentYY
      // Reaction/edit/hide buttons have event.stopPropagation() so they don't trigger that.
      return `
        <div class="postItem" id="comment-${commentId}" onclick="window.location.hash='post${postId}/#comment${commentId}'">
          <div class="postHeader">
            <div class="authorInfo">
              ${getAvatarHTML(authorDisplay)}
              <div class="authorDetails">
                <a href="#${authorDisplay.usernameOnly}"><span class="authorName">@${authorDisplay.usernameOnly}</span></a>
                <div class="postDate">${formatTimestamp(cData[6])}</div>
              </div>
            </div>
            <div class="reactionRow">
              <span class="reactionBtn like" title="Like" onclick="reactToComment(${postId}, ${commentId}, 'like'); event.stopPropagation();"><i class="fas fa-thumbs-up"></i></span>
              <span class="reactionBtn dislike" title="Dislike" onclick="reactToComment(${postId}, ${commentId}, 'dislike'); event.stopPropagation();"><i class="fas fa-thumbs-down"></i></span>
              ${
                userAccount && userAccount.toLowerCase() === authorAddr.toLowerCase()
                  ? `
                    <a href="#editcomment-${postId}-${commentId}" onclick="event.stopPropagation();">
                      <span class="reactionBtn" title="Edit"><i class="fas fa-pen"></i></span>
                    </a>
                    <span class="reactionBtn" title="Hide" onclick="toggleHideComment(${postId}, ${commentId}, true); event.stopPropagation();"><i class="fas fa-eye"></i>️</span>
                  `
                  : ``
              }
            </div>
          </div>
          <div class="postText"><p>${formatMarkdown(cData[2])}</p></div>
          <div class="statsLine">Likes: ${cData[4]} | Dislikes: ${cData[5]}</div>
        </div>
      `;
    }

    /* =================== Shared function for appending a post to feed =================== */
    async function appendPostToFeed(feedContainer, post) {
      const authorDisplay = await getUserDisplayName(post[1]);
      const div = document.createElement("div");
      div.className = "postItem";
      div.id = "post-" + post[0];
      div.addEventListener('click', () => { window.location.hash = "post" + post[0]; });

      let contentHTML = post[8]
        ? await renderRepost(post)
        : getTruncatedContent(post[0], post[7]);
      
      div.innerHTML = `
        <div class="postHeader">
          <div class="authorInfo">
            ${getAvatarHTML(authorDisplay)}
            <div class="authorDetails">
              <a href="#${authorDisplay.usernameOnly}"><span class="authorName">${authorDisplay.displayName}</span></a>
              <div class="postDate">${formatTimestamp(post[3])}</div>
            </div>
          </div>
          <div class="reactionRow">
            <span class="reactionBtn like" title="Like" onclick="reactToPost(${post[0]}, 'like'); event.stopPropagation();"><i class="fas fa-thumbs-up"></i></span>
            <span class="reactionBtn dislike" title="Dislike" onclick="reactToPost(${post[0]}, 'dislike'); event.stopPropagation();"><i class="fas fa-thumbs-down"></i></span>
            <span class="reactionBtn shareBtn" title="Share" onclick="showShareOptions(${post[0]}, event); event.stopPropagation();"><i class="fas fa-share"></i></span>
          </div>
        </div>
        <div class="postText"><p>${contentHTML}</p></div>
        <div class="statsLine">
          Likes: ${post[5]} | Dislikes: ${post[6]} | Comments: ${post[4]} | Reposts: ${post[10]}
        </div>
      `;
      feedContainer.appendChild(div);
      checkPostReaction(post[0], div);
    }

    /* =================== Reactions, Repost Rendering =================== */
    async function reactToPost(postId, reaction) {
      if (!userContract || !userAccount) return showMessage("Connect wallet to react.", true);
      if (!isRegistered) return showMessage("You must be registered to react.", true);
      try {
        const currentReaction = await readOnlyContract.methods.getUserReactionOnPost(postId, userAccount).call();
        const newReaction = (currentReaction === reaction) ? "none" : reaction;
        await userContract.methods.reactToPost(postId, newReaction).send({ from: userAccount });
        showMessage("Post reaction updated!", false);
        // Get the post container by its id
        const container = document.getElementById("post-" + postId);
        if (container) {
          // Call container to update the UI
          checkPostReaction(postId, container);
        }
      } catch(e) {
        showMessage("Error reacting to post: " + e.message, true);
      }
    }
    async function reactToComment(postId, commentId, reaction) {
      if (!userContract || !userAccount) return showMessage("Connect wallet to react.", true);
      if (!isRegistered) return showMessage("You must be registered to react.", true);
      try {
        const currentReaction = await readOnlyContract.methods.getUserReactionOnComment(postId, commentId, userAccount).call();
        const newReaction = (currentReaction === reaction) ? "none" : reaction;
        await userContract.methods.reactToComment(postId, commentId, newReaction).send({ from: userAccount });
        showMessage("Comment reaction updated!", false);
        // Get the comment container by its id (set in buildCommentHTML)
        const commentContainer = document.getElementById("comment-" + commentId);
        if (commentContainer) {
          // Call checkCommentReaction to update the UI
          checkCommentReaction(postId, commentId, commentContainer);
        }
      } catch(e) {
        showMessage("Error reacting to comment: " + e.message, true);
      }
    }
    async function checkPostReaction(postId, container) {
      if (!userAccount) return;
      try {
        const likeBtn = container.querySelector(".reactionBtn.like");
        const dislikeBtn = container.querySelector(".reactionBtn.dislike");
        if (likeBtn) likeBtn.classList.remove("highlight");
        if (dislikeBtn) dislikeBtn.classList.remove("highlight");

        const reaction = await readOnlyContract.methods.getUserReactionOnPost(postId, userAccount).call();
        if (reaction === "like" && likeBtn) likeBtn.classList.add("highlight");
        else if (reaction === "dislike" && dislikeBtn) dislikeBtn.classList.add("highlight");
      } catch(e) { console.log(e); }
    }
    async function checkCommentReaction(postId, commentId, container) {
      if (!userAccount) return;
      try {
        const likeBtn = container.querySelector(".reactionBtn.like");
        const dislikeBtn = container.querySelector(".reactionBtn.dislike");
        if (likeBtn) likeBtn.classList.remove("highlight");
        if (dislikeBtn) dislikeBtn.classList.remove("highlight");

        const reaction = await readOnlyContract.methods.getUserReactionOnComment(postId, commentId, userAccount).call();
        if (reaction === "like" && likeBtn) likeBtn.classList.add("highlight");
        else if (reaction === "dislike" && dislikeBtn) dislikeBtn.classList.add("highlight");
      } catch (e) {
        console.log(e);
      }
    }
    async function renderRepost(post) {
      let reposterNote = (post[7] || "").trim();
      const reposterInfo = await getUserDisplayName(post[1]);
      if (!reposterNote) {
        reposterNote = "User @" + reposterInfo.usernameOnly + " has reposted this:";
      }
      const originalPost = await readOnlyContract.methods.getPost(post[9]).call();
      if (!originalPost[0]) return `<i>Original post not found.</i>`;

      const originalAuthor = await getUserDisplayName(originalPost[1]);
      
      const originalContentHTML = getTruncatedContent(post[9], originalPost[7]);
      
      const originalHTML = `
        <a href="#post${post[9]}" style="text-decoration: none; color: inherit;" onclick="event.stopPropagation();">
          <div class="quotedFrame">
            <div class="postHeader">
              <div class="authorInfo">
                ${getAvatarHTML(originalAuthor)}
                <div class="authorDetails">
                  <span class="authorName">${originalAuthor.usernameOnly}</span>
                  <div class="postDate">${formatTimestamp(originalPost[3])}</div>
                </div>
              </div>
            </div>
            <div class="postText"><p>${originalContentHTML}</p></div>
            <div class="statsLine">
              Likes: ${originalPost[5]} | Dislikes: ${originalPost[6]} | Comments: ${originalPost[4]} | Reposts: ${originalPost[10]}
            </div>
          </div>
        </a>
      `;
      return `<div class="repostBlock">
                <p><em>${getTruncatedContent(post[0], reposterNote)}</em></p>
                ${originalHTML}
              </div>`;
    }

    /* =================== Creating/Hiding/Editing Posts & Comments =================== */
    async function createCommentOnPost() {
      if (!userContract || !userAccount) return showMessage("Connect wallet to comment.", true);
      if (!isRegistered) return showMessage("You must be registered to comment.", true);

      const text = document.getElementById("commentText").value.trim();
      if (!text) return showMessage("Comment is empty.", true);

      try {
        await userContract.methods.createComment(currentPostId, text).send({ from: userAccount });
        showMessage("Comment posted!", false);
        document.getElementById("commentText").value = "";
        loadSinglePost(currentPostId);
      } catch(e) {
        showMessage("Error creating comment: " + e.message, true);
      }
    }
    async function toggleHidePost(postId, hidden) {
      if (!userAccount) return;
      try {
        await userContract.methods.hidePost(postId, hidden).send({ from: userAccount });
        showMessage(hidden ? "Post hidden." : "Post unhidden.", false);
        if (window.location.hash.startsWith("#post")) {
          loadSinglePost(postId);
        } else {
          reloadMyPosts();
        }
      } catch(e) {
        showMessage("Error toggling post visibility: " + e.message, true);
      }
    }
    async function toggleHideComment(postId, commentId, hidden) {
      if (!userAccount) return;
      try {
        await userContract.methods.hideComment(postId, commentId, hidden).send({ from: userAccount });
        showMessage(hidden ? "Comment hidden." : "Comment unhidden.", false);
        loadSinglePost(postId);
      } catch(e) {
        showMessage("Error toggling comment visibility: " + e.message, true);
      }
    }
    async function loadEditPost(postId) {
      let isRepost = false;
      try {
        const post = await readOnlyContract.methods.getPost(postId).call();
        if (!post[0] || post[11]) {
          showMessage("Post not found or hidden.", true);
          return;
        }
        if (post[8]) {
          // It's a repost
          isRepost = true;
          let reposterNote = (post[7] || "").trim();
          if (!reposterNote) {
            const reposterInfo = await getUserDisplayName(post[1]);
            reposterNote = "User @" + reposterInfo.usernameOnly + " has reposted this:";
          }
          editPostContent.value = reposterNote;

          const originalPost = await readOnlyContract.methods.getPost(post[9]).call();
          if (originalPost[0]) {
            const originalAuthor = await getUserDisplayName(originalPost[1]);
            originalPostQuote.innerHTML = `
              <div class="postHeader">
                <div class="authorInfo">
                  ${getAvatarHTML(originalAuthor)}
                  <div class="authorDetails">
                    <a href="#${originalAuthor.usernameOnly}"><span class="authorName">${originalAuthor.displayName}</span></a>
                    <div class="postDate">${formatTimestamp(originalPost[3])}</div>
                  </div>
                </div>
              </div>
              <div class="postText"><p>${formatMarkdown(originalPost[7])}</p></div>
              <div class="statsLine">
                Likes: ${originalPost[5]} | Dislikes: ${originalPost[6]} | Comments: ${originalPost[4]} | Reposts: ${originalPost[10]}
              </div>
            `;
            originalPostQuote.style.display = "block";
          }
        } else {
          editPostContent.value = post[7];
          originalPostQuote.style.display = "none";
        }
      } catch(e) {
        showMessage("Error loading post for edit: " + e.message, true);
      }
      saveEditPostBtn.onclick = async () => {
        const newContent = editPostContent.value.trim();
        if (!newContent) return showMessage("Post content cannot be empty.", true);
        try {
          if (isRepost) {
            await userContract.methods.editRepost(postId, newContent).send({ from: userAccount });
          } else {
            await userContract.methods.editPost(postId, newContent).send({ from: userAccount });
          }
          showMessage("Post updated.", false);
          window.location.hash = "post" + postId;
        } catch(e) {
          showMessage("Error editing post: " + e.message, true);
        }
      };
    }
    async function loadEditComment(postId, commentId) {
      try {
        const cData = await readOnlyContract.methods.getComment(postId, commentId).call();
        if (!cData[0] || cData[7]) {
          showMessage("Comment not found or hidden.", true);
          return;
        }
        editCommentContent.value = cData[2];
      } catch(e) {
        showMessage("Error loading comment for edit: " + e.message, true);
      }
      saveEditCommentBtn.onclick = async () => {
        const newText = editCommentContent.value.trim();
        if (!newText) return showMessage("Comment cannot be empty.", true);
        try {
          await userContract.methods.editComment(postId, commentId, newText).send({ from: userAccount });
          showMessage("Comment updated.", false);
          window.location.hash = "post" + postId;
        } catch(e) {
          showMessage("Error editing comment: " + e.message, true);
        }
      };
    }
    async function loadRepost(postId) {
      try {
        const post = await readOnlyContract.methods.getPost(postId).call();
        if(!post[0] || post[11]) {
          showMessage("Original post not found or hidden.", true);
          return;
        }
        // Show original in quotedFrame
        const authorDisp = await getUserDisplayName(post[1]);
        const contentHTML = post[8] ? await renderRepost(post) : formatMarkdown(post[7]);
        originalPostFrame.innerHTML = `
          <div class="postItem" style="cursor:auto;">
            <div class="postHeader">
              <div class="authorInfo">
                ${getAvatarHTML(authorDisp)}
                <div class="authorDetails">
                  <span class="authorName">${authorDisp.usernameOnly}</span>
                  <div class="postDate">${formatTimestamp(post[3])}</div>
                </div>
              </div>
            </div>
            <div class="postText"><p>${contentHTML}</p></div>
            <div class="statsLine">Likes: ${post[5]} | Dislikes: ${post[6]} | Comments: ${post[4]} | Reposts: ${post[10]}</div>
          </div>
        `;
      } catch(e) {
        showMessage("Error loading original post: " + e.message, true);
      }
      submitRepostBtn.onclick = async () => {
        const note = repostContent.value.trim();
        try {
          await userContract.methods.createRepost(postId, note).send({ from: userAccount });
          showMessage("Post reposted.", false);
          window.location.hash = "post" + postId;
        } catch(e) {
          showMessage("Error reposting: " + e.message, true);
        }
      };
    }

    /* =================== My Profile (Load 5 first, 5 on scroll) =================== */
    async function loadMyProfile() {
      const header = document.getElementById("myProfileHeader");
      header.innerHTML = "";

      if (!userAccount) {
        header.innerHTML = `
          <div class="panel">
            <h2>Not Connected</h2>
            <p>Please connect your wallet to see your profile.</p>
          </div>`;
        if (createPostPanel && createPostPanel.querySelector("textarea")) {
          createPostPanel.querySelector("textarea").disabled = true;
        }
        createPostBtn.textContent = "Connect Wallet";
        createPostBtn.onclick = connectWallet;
        myProfileTabs.style.display = "none";
        return;
      }

      if (!isRegistered) {
        header.innerHTML = `
          <div class="panel" id="registrationPanel">
            <h2>Create an Account</h2>
            <p>You must register before using your profile. Enter nickname + username below:</p><br/>
            <input type="text" id="regNickname" placeholder="Nickname (your display name)" /><br/><br/>
            <input type="text" id="regUsername" placeholder="Username (at least 5 characters)" /><br/><br/>
            <button id="regNowBtn">Register</button>
          </div>
        `;
        safeAddEventListener("regNowBtn", "click", doRegister);
        if (createPostPanel && createPostPanel.querySelector("textarea")) {
          createPostPanel.querySelector("textarea").disabled = true;
        }
        createPostBtn.textContent = "Create an account to post";
        createPostBtn.onclick = () => showMessage("Please register first.", true);
        myProfileTabs.style.display = "none";
        return;
      }

      try {
        showLoader();
        
        myProfileTabs.style.display = "flex";
        const p = await userContract.methods.getUserProfile(userAccount).call();
        const basic = await userContract.methods.getUserBasic(userAccount).call();
        currentUsername = basic[1];
        const pinnedPostId = p[6];
        window.pinnedPostId = pinnedPostId;

        header.innerHTML = `
          <div class="panel" id="myProfileDisplay" style="position: relative;">
            <div class="coverContainer">
              ${
                p[5]
                  ? `<img id="myCoverPhoto" src="${p[5]}" alt="My Cover">`
                  : `<div id="myCoverFallback" class="coverFallback"></div>`
              }
              <div class="avatarContainer">
                ${
                  p[4]
                    ? `<img id="myProfileAvatar" src="${p[4]}" alt="My Avatar">`
                    : `<div id="myAvatarFallback" class="avatarFallback">${p[0]?.charAt(0).toUpperCase() || ""}</div>`
                }
              </div>
              <button onclick="shareProfile()" class="shareProfileButton">
                Share Profile
              </button>
            </div>
            <h2 id="myNicknameLine">${p[0]}</h2>
            <p id="myUsernameLine">@${basic[1]}</p>
            <p id="myBioLine">${p[1] || ""}</p>
            <div style="display: flex; align-items: center; gap: 15px;">
              ${
                p[3]
                  ? `<p id="myLocationLine"><i class="fas fa-location-pin"></i> ${p[3]}</p>`
                  : ""
              }
              ${
                p[2]
                  ? `<p id="myWebsiteLine"><i class="fas fa-globe"></i> <a href="${p[2].startsWith("http") ? p[2] : "http://${p[2]}" }" target="_blank">${p[2]}</a></p>`
                  : ""
              }
            </div>
            <p id="myStats"></p>
          </div>
        `;

        const stats = await readOnlyContract.methods.getUserStats(userAccount).call();
        myStats.textContent = `${stats[0]} Posts - ${stats[2]} Followers - ${stats[3]} Following | Joined: ${formatTimestampZ(basic[2])}`;

        loadPinnedPost();

        if (createPostPanel && createPostPanel.querySelector("textarea")) {
          createPostPanel.querySelector("textarea").disabled = false;
        }
        createPostBtn.textContent = "Post";

        // default tab
        document.getElementById("myProfilePostsSection").style.display = "block";
        document.getElementById("myProfileCommentsSection").style.display = "none";
        showMyPosts();
        
        hideLoader();
      } catch(e) {
        console.log("Error loadMyProfile:", e);
        showMessage("Couldn't load your profile: " + e.message, true);
      }
    }
    function showMyPosts() {
      myProfilePostsTab.classList.add("activeTab");
      myProfileCommentsTab.classList.remove("activeTab");
      myProfilePostsSection.style.display = "block";
      myProfileCommentsSection.style.display = "none";
      reloadMyPosts();
    }
    function showMyComments() {
      myProfileCommentsTab.classList.add("activeTab");
      myProfilePostsTab.classList.remove("activeTab");
      myProfileCommentsSection.style.display = "block";
      myProfilePostsSection.style.display = "none";
      loadMyCommentsInitial();
    }

    // My Posts
    async function reloadMyPosts() {
      myPostsFeed.innerHTML = "";
      myHasMorePosts = true;
      myLastPost = 0;
      loadedMyPostIds.clear();

      try {
        const stats = await readOnlyContract.methods.getUserStats(userAccount).call();
        const total = parseInt(stats[0],10);
        if (total <= 0) {
          myPostsFeed.innerHTML = "<p>No posts yet.</p>";
          myHasMorePosts = false;
          return;
        }
        myLastPost = total;
        await loadMoreMyPosts(5);  // initial = 5

        // Window-based infinite scroll
        window.onscroll = async function() {
          const route = window.location.hash;
          if (route !== "#profile") return;
          if (!myHasMorePosts || myLoadingPosts) return;
          if (window.innerHeight + window.pageYOffset >= document.body.offsetHeight - 50) {
            myLoadingPosts = true;
            await loadMoreMyPosts(5);
            myLoadingPosts = false;
          }
        };
      } catch(e) {
        console.log("reloadMyPosts error:", e);
      }
    }
    async function loadMoreMyPosts(batchSize) {
      if (!myHasMorePosts || myLastPost < 1) return;
      const feed = document.getElementById("myPostsFeed");

      let start = myLastPost;
      let end = start - batchSize + 1;
      if (end < 1) end = 1;

      for (let i = start; i >= end; i--) {
        try {
          const globalId = await readOnlyContract.methods.getGlobalPostId(userAccount, i).call();
          const post = await readOnlyContract.methods.getPost(globalId).call();
          if (!post[0]) continue;
          // skip if hidden or already loaded
          if (loadedMyPostIds.has(post[0])) continue;
          loadedMyPostIds.add(post[0]);
          await appendMyPost(post);
        } catch(e) {
          console.log("Error loading my post #", i, e);
        }
      }
      myLastPost = end - 1;
      if (myLastPost < 1) {
        myHasMorePosts = false;
      }
    }
    async function appendMyPost(post) {
      const feed = document.getElementById("myPostsFeed");
      const myDisplay = await getUserDisplayName(userAccount);
      const div = document.createElement("div");
      div.className = "postItem";
      div.id = "post-" + post[0];
      div.addEventListener('click', () => { window.location.hash = "post" + post[0]; });

      let optionsHTML = "";
      if (!post[11] && userAccount.toLowerCase() === post[1].toLowerCase()) {
        if (post[0] == window.pinnedPostId) {
          optionsHTML = `
            <div class="postOptions">
              <a href="#editpost-${post[0]}"><button><i class="fas fa-pen"></i> Edit</button></a>
              <button onclick="toggleHidePost(${post[0]}, true); event.stopPropagation();"><i class="fas fa-eye"></i>️ Hide</button>
              <button onclick="unpinMyPost(); event.stopPropagation();"><i class="fas fa-thumbtack-slash"></i> Unpin</button>
            </div>
          `;
        } else {
          optionsHTML = `
            <div class="postOptions">
              <a href="#editpost-${post[0]}"><button><i class="fas fa-pen"></i> Edit</button></a>
              <button onclick="toggleHidePost(${post[0]}, true); event.stopPropagation();"><i class="fas fa-eye"></i>️ Hide</button>
              <button onclick="pinMyPost(${post[0]}); event.stopPropagation();"><i class="fas fa-thumbtack"></i> Pin</button>
            </div>
          `;
        }
      } else if (post[11]) {
        // hidden
        optionsHTML = `
          <div class="postHiddenMessage">
            This post is hidden. 
            <button onclick="toggleHidePost(${post[0]}, false); event.stopPropagation();"><i class="fas fa-eye-slash"></i>️ Unhide</button>
          </div>
        `;
      }

      let contentHTML = post[8]
        ? await renderRepost(post)
        : getTruncatedContent(post[0], post[7]);
    
      div.innerHTML = `
        <div class="postHeader">
          <div class="authorInfo">
            ${getAvatarHTML(myDisplay)}
            <div class="authorDetails">
              <a href="#profile"><span class="authorName">${myDisplay.displayName}</span></a>
              <div class="postDate">${formatTimestamp(post[3])}</div>
            </div>
          </div>
          <div class="reactionRow">
            <span class="reactionBtn like" title="Like" onclick="reactToPost(${post[0]}, 'like'); event.stopPropagation();"><i class="fas fa-thumbs-up"></i></span>
            <span class="reactionBtn dislike" title="Dislike" onclick="reactToPost(${post[0]}, 'dislike'); event.stopPropagation();"><i class="fas fa-thumbs-down"></i></span>
            <span class="reactionBtn shareBtn" title="Share" onclick="showShareOptions(${post[0]}, event); event.stopPropagation();"><i class="fas fa-share"></i></span>
          </div>
        </div>
        <div class="postText">
          <p>${contentHTML}</p>
        </div>
        <div class="statsLine">
          Likes: ${post[5]} | Dislikes: ${post[6]} | Comments: ${post[4]} | Reposts: ${post[10]}
        </div>
        ${optionsHTML}
      `;
      feed.appendChild(div);
      checkPostReaction(post[0], div);
    }

    // My Comments
    function loadMyCommentsInitial() {
      myCommentsFeed.innerHTML = "";
      myHasMoreComments = true;
      myLastComment = 0;
      
      readOnlyContract.methods.getUserCommentCount(userAccount).call().then(total => {
        const t = parseInt(total,10);
        if (t <= 0) {
          myCommentsFeed.innerHTML = "<p>No comments yet.</p>";
          myHasMoreComments = false;
          return;
        }
        myLastComment = t;
        loadMoreMyComments(5); // first load 5

        myCommentsFeed.addEventListener("scroll", myCommentsScrollHandler);
      }).catch(e => console.log(e));
    }
    async function myCommentsScrollHandler() {
      if (!myHasMoreComments || myLoadingComments) return;
      if (myCommentsFeed.scrollTop + myCommentsFeed.clientHeight >= myCommentsFeed.scrollHeight - 10) {
        myLoadingComments = true;
        await loadMoreMyComments(5);
        myLoadingComments = false;
      }
    }
    async function loadMoreMyComments(batchSize) {
      if (!myHasMoreComments || myLastComment < 1) return;

      let start = myLastComment;
      let end = start - batchSize + 1;
      if (end < 1) end = 1;

      for (let i = start; i >= end; i--) {
        try {
          const info = await readOnlyContract.methods.getUserComment(userAccount, i).call();
          const globalPostId = info[0];
          const commentId = info[1];
          if (parseInt(globalPostId,10)===0) continue;
          const cData = await readOnlyContract.methods.getComment(globalPostId, commentId).call();
          // Only skip if the comment doesn't exist
          if (!cData[0]) continue;
          // Do NOT skip hidden comments now; let appendMyComment handle them.
          await appendMyComment(cData, globalPostId);
        } catch(e) {
          console.log("Error loading my comment #", i, e);
        }
      }
      myLastComment = end - 1;
      if (myLastComment < 1) {
        myHasMoreComments = false;
      }
    }
    async function appendMyComment(cData, globalPostId) {
      const commenter = await getUserDisplayName(cData[3]);
      const div = document.createElement("div");
      div.className = "activityItem";

      let innerHTML = "";
      if (cData[7]) { // comment is hidden
        if (userAccount && userAccount.toLowerCase() === cData[3].toLowerCase()) {
          // Owner sees an Unhide button
          innerHTML = `
            <p class="commentTitle">
              <b>${commenter.displayName}</b> commented on post <a href="#post${globalPostId}"><b>#${globalPostId}</b></a>:
            </p>
            <p><i>${formatMarkdown(cData[2])}</i></p>
            <p><i>This comment is hidden.</i> <button onclick="toggleHideComment(${globalPostId}, ${cData[1]}, false); event.stopPropagation();"><i class="fas fa-eye-slash"></i> Unhide Comment</button></p>
            <span style="font-size:0.8rem; opacity:0.7;">${formatTimestamp(cData[6])}</span>
          `;
        } else {
          // Other users see a message and a link
          innerHTML = ``;
        }
      } else {
        innerHTML = `
          <p class="commentTitle">
            <b>${commenter.displayName}</b> commented on post <b>#${globalPostId}</b>:
          </p>
          <p><i>${formatMarkdown(cData[2])}</i></p>
          <span style="font-size:0.8rem; opacity:0.7;">${formatTimestamp(cData[6])}</span>
        `;
      }
  
      div.innerHTML = `<a href="#post${globalPostId}/#comment${cData[1]}" style="text-decoration:none; color:inherit;">${innerHTML}</a>`;
      myCommentsFeed.appendChild(div);
    }

    /* =================== Public User Profile (Use window scroll, same as My Profile) =================== */
    async function loadUserProfile(username) {
      showLoader();
        
      // Clear the header area
      const coverPhoto = document.getElementById("coverPhoto");
      const coverFallback = document.getElementById("coverFallback");
      coverPhoto.style.display = "none"; 
      coverFallback.style.display = "none";

      const avatarImg = document.getElementById("profileAvatar");
      const avatarFallback = document.getElementById("avatarFallback");
      avatarImg.style.display = "none"; 
      avatarFallback.style.display = "none";

      nicknameLine.textContent = "";
      usernameLine.textContent = "";
      bioLine.textContent = "";
      locationLine.innerHTML = "";
      websiteLine.textContent = "";
      joinedDate.textContent = "";
      followerStats.textContent = "";
      userFeed.innerHTML = "";
      followBtn.style.display = "none";

      loadedUserPostIds.clear(); // reset user feed set

      try {
        const userAddr = await readOnlyContract.methods.getUserAddressByUsername(username).call();
        if (userAddr === "0x0000000000000000000000000000000000000000") {
          userFeed.innerHTML = "<p>User not found.</p>";
          hideLoader();
          return;
        }
        currentProfileUserAddr = userAddr;

        const basic = await readOnlyContract.methods.getUserBasic(userAddr).call();
        const p = await readOnlyContract.methods.getUserProfile(userAddr).call();
        const stats = await readOnlyContract.methods.getUserStats(userAddr).call();

        nicknameLine.textContent = p[0];
        usernameLine.textContent = "@" + basic[1];
        if (p[1]) bioLine.textContent = p[1];
        if (p[3]) locationLine.innerHTML = '<i class="fas fa-location-pin"></i> ' + p[3];
        if (p[2]) {
          let url = p[2];
          if (!url.startsWith("http://") && !url.startsWith("https://")) url = "http://" + url;
          websiteLine.innerHTML = '<i class="fas fa-globe"></i> <a href="' + url + '" target="_blank">' + p[2] + '</a>';
        }
        followerStats.textContent = stats[0] + " Posts - " + stats[2] + " Followers - " + stats[3] + " Following";
        joinedDate.textContent = "Joined " + new Date(parseInt(basic[2],10)*1000).toLocaleDateString('en-US', {year:'numeric', month:'long'});
        
        // Cover
        if (p[5]) {
          coverPhoto.src = p[5];
          coverPhoto.style.display = "block";
        } else {
          coverFallback.style.display = "block";
        }
        // Avatar
        if (p[4]) {
          avatarImg.src = p[4];
          avatarImg.style.display = "block";
        } else {
          avatarFallback.style.display = "flex";
          avatarFallback.textContent = p[0] ? p[0].charAt(0).toUpperCase() : "?";
        }

        // Follow button
        if (userAccount && userAccount.toLowerCase() !== userAddr.toLowerCase()) {
          followBtn.style.display = "inline-block";
          const isF = await readOnlyContract.methods.getIsFollowing(userAccount, userAddr).call();
          followBtn.textContent = isF ? "Unfollow" : "Follow";
          followBtn.onclick = () => toggleFollow(userAddr, !isF);
        }

        // pinned
        if (parseInt(p[6],10) > 0) {
          const pinnedPost = await readOnlyContract.methods.getPost(p[6]).call();
          if (pinnedPost[0]) {
            const pinnedAuthor = await getUserDisplayName(userAddr);
            
            let contentHTML = pinnedPost[8]
                  ? await renderRepost(pinnedPost)
                  : getTruncatedContent(pinnedPost[0], pinnedPost[7]);
                  
            userPinnedContent.innerHTML = `
              <div class="postItem" onclick="window.location.hash='post${pinnedPost[0]}'">
                <div class="postHeader">
                  <div class="authorInfo">
                    ${getAvatarHTML(pinnedAuthor)}
                    <div class="authorDetails">
                      <a href="#${pinnedAuthor.usernameOnly}"><span class="authorName">${pinnedAuthor.displayName}</span></a>
                      <div class="postDate">${formatTimestamp(pinnedPost[3])}</div>
                    </div>
                  </div>
                  <div class="reactionRow">
                    <span class="reactionBtn like" title="Like" onclick="reactToPost(${pinnedPost[0]}, 'like'); event.stopPropagation();"><i class="fas fa-thumbs-up"></i></span>
                    <span class="reactionBtn dislike" title="Dislike" onclick="reactToPost(${pinnedPost[0]}, 'dislike'); event.stopPropagation();"><i class="fas fa-thumbs-down"></i></span>
                    <span class="reactionBtn shareBtn" title="Share" onclick="showShareOptions(${pinnedPost[0]}, event); event.stopPropagation();"><i class="fas fa-share"></i></span>
                  </div>
                </div>
                <div class="postText"><p>${contentHTML}</p></div>
                <div class="statsLine">Likes: ${pinnedPost[5]} | Dislikes: ${pinnedPost[6]} | Comments: ${pinnedPost[4]} | Reposts: ${pinnedPost[10]}</div>
              </div>
            `;
            userPinnedPanel.style.display = "block";
          }
        } else {
          userPinnedPanel.style.display = "none";
        }

        // default: show posts
        profilePostsSection.style.display = "block";
        profileCommentsSection.style.display = "none";
        profilePostsTab.classList.add("activeTab");
        profileCommentsTab.classList.remove("activeTab");

        reloadUserPosts(username); 
        
        hideLoader();
      } catch(e) {
        userFeed.innerHTML = "<p>Error loading user profile.</p>";
        console.log(e);
      }
    }
    function showUserPosts() {
      profilePostsTab.classList.add("activeTab");
      profileCommentsTab.classList.remove("activeTab");
      profilePostsSection.style.display = "block";
      profileCommentsSection.style.display = "none";
      reloadUserPosts(currentUsername);
    }
    function showUserComments() {
      profileCommentsTab.classList.add("activeTab");
      profilePostsTab.classList.remove("activeTab");
      profileCommentsSection.style.display = "block";
      profilePostsSection.style.display = "none";
      loadUserCommentsInitial();
    }

    async function reloadUserPosts(username) {
      userFeed.innerHTML = "";
      userHasMorePosts = true;
      userLastPost = 0;
      loadedUserPostIds.clear();

      try {
        const stat = await readOnlyContract.methods.getUserStats(currentProfileUserAddr).call();
        const totalPosts = parseInt(stat[0],10);
        if (totalPosts <= 0) {
          userFeed.innerHTML = "<p>No posts yet.</p>";
          userHasMorePosts = false;
          return;
        }
        userLastPost = totalPosts;
        await loadMoreUserPosts(5);

        window.onscroll = async function() {
          // Make sure user is still on this route
          if (window.location.hash === "#" + username) {
            if (!userHasMorePosts || userLoadingPosts) return;
            if (window.innerHeight + window.pageYOffset >= document.body.offsetHeight - 50) {
              userLoadingPosts = true;
              await loadMoreUserPosts(5);
              userLoadingPosts = false;
            }
          }
        };
      } catch(e) {
        console.log("reloadUserPosts error:", e);
      }
    }
    async function loadMoreUserPosts(batchSize) {
      if (!userHasMorePosts || userLastPost < 1) return;

      let start = userLastPost;
      let end = start - batchSize + 1;
      if (end < 1) end = 1;

      for (let i = start; i >= end; i--) {
        try {
          const globalId = await readOnlyContract.methods.getGlobalPostId(currentProfileUserAddr, i).call();
          const post = await readOnlyContract.methods.getPost(globalId).call();
          if (!post[0] || post[11]) continue;
          if (loadedUserPostIds.has(post[0])) continue;
          loadedUserPostIds.add(post[0]);
          await appendUserPost(post);
        } catch(e) {
          console.log("Error loading user post #", i, e);
        }
      }
      userLastPost = end - 1;
      if (userLastPost < 1) {
        userHasMorePosts = false;
      }
    }
    async function appendUserPost(post) {
      const feed = document.getElementById("userFeed");
      const authorDisplay = await getUserDisplayName(post[1]);
      const div = document.createElement("div");
      div.className = "postItem";
      div.id = "post-" + post[0];
      div.addEventListener('click', () => { window.location.hash = "post" + post[0]; });

      let contentHTML = post[8]
        ? await renderRepost(post)
        : getTruncatedContent(post[0], post[7]);
      
      div.innerHTML = `
        <div class="postHeader">
          <div class="authorInfo">
            ${getAvatarHTML(authorDisplay)}
            <div class="authorDetails">
              <a href="#${authorDisplay.usernameOnly}"><span class="authorName">${authorDisplay.displayName}</span></a>
              <div class="postDate">${formatTimestamp(post[3])}</div>
            </div>
          </div>
          <div class="reactionRow">
            <span class="reactionBtn like" title="Like" onclick="reactToPost(${post[0]}, 'like'); event.stopPropagation();"><i class="fas fa-thumbs-up"></i></span>
            <span class="reactionBtn dislike" title="Dislike" onclick="reactToPost(${post[0]}, 'dislike'); event.stopPropagation();"><i class="fas fa-thumbs-down"></i></span>
            <span class="reactionBtn shareBtn" title="Share" onclick="showShareOptions(${post[0]}, event); event.stopPropagation();"><i class="fas fa-share"></i></span>
          </div>
        </div>
        <div class="postText"><p>${contentHTML}</p></div>
        <div class="statsLine">
          Likes: ${post[5]} | Dislikes: ${post[6]} | Comments: ${post[4]} | Reposts: ${post[10]}
        </div>
      `;
      feed.appendChild(div);
      checkPostReaction(post[0], div);
    }

    // User comments
    function loadUserCommentsInitial() {
      userCommentsFeed.innerHTML = "";
      userHasMoreComments = true;
      userLastComment = 0;

      readOnlyContract.methods.getUserCommentCount(currentProfileUserAddr).call().then(total => {
        const t = parseInt(total,10);
        if (t <= 0) {
          userCommentsFeed.innerHTML = "<p>No comments yet.</p>";
          userHasMoreComments = false;
          return;
        }
        userLastComment = t;
        loadMoreUserComments(5);

        userCommentsFeed.removeEventListener("scroll", userCommentsScrollHandler);
        userCommentsFeed.addEventListener("scroll", userCommentsScrollHandler);
      }).catch(e => console.log("loadUserCommentsInitial error:", e));
    }
    async function userCommentsScrollHandler() {
      if (!userHasMoreComments || userLoadingComments) return;
      if (userCommentsFeed.scrollTop + userCommentsFeed.clientHeight >= userCommentsFeed.scrollHeight - 10) {
        userLoadingComments = true;
        await loadMoreUserComments(5);
        userLoadingComments = false;
      }
    }
    async function loadMoreUserComments(batchSize) {
      if (!userHasMoreComments || userLastComment < 1) return;

      let start = userLastComment;
      let end = start - batchSize + 1;
      if (end < 1) end = 1;

      for (let i = start; i >= end; i--) {
        try {
          const info = await readOnlyContract.methods.getUserComment(currentProfileUserAddr, i).call();
          const globalPostId = info[0];
          const commentId = info[1];
          if (parseInt(globalPostId,10) === 0) continue;
          const cData = await readOnlyContract.methods.getComment(globalPostId, commentId).call();
          if (!cData[0] || cData[7]) continue; 
          await appendUserComment(cData, globalPostId);
        } catch(e) {
          console.log("Error loading user comment #", i, e);
        }
      }
      userLastComment = end - 1;
      if (userLastComment < 1) {
        userHasMoreComments = false;
      }
    }
    async function appendUserComment(cData, globalPostId) {
      const commenter = await getUserDisplayName(cData[3]);
      const div = document.createElement("div");
      div.className = "activityItem";
      div.innerHTML = `
        <a href="#post${globalPostId}/#comment${cData[1]}" style="text-decoration:none; color:inherit;">
          <p class="commentTitle">
            <b>${commenter.displayName}</b> commented on post <b>#${globalPostId}</b>:
          </p>
          <p><i>${formatMarkdown(cData[2])}</i></p>
          <span style="font-size:0.8rem; opacity:0.7;">${formatTimestamp(cData[6])}</span>
        </a>
      `;
      userCommentsFeed.appendChild(div);
    }

    /* =================== Pin / Unpin =================== */
    async function pinMyPost(postId) {
      if (!userContract || !userAccount) return showMessage("Connect wallet to pin posts.", true);
      try {
        await userContract.methods.pinPost(postId).send({ from: userAccount });
        showMessage("Post pinned.", false);
        loadPinnedPost();
      } catch(e) {
        showMessage("Error pinning post: " + e.message, true);
      }
    }
    async function unpinMyPost() {
      if (!userContract || !userAccount) return showMessage("Connect wallet to unpin posts.", true);
      try {
        await userContract.methods.pinPost(0).send({ from: userAccount });
        showMessage("Post unpinned.", false);
        loadPinnedPost();
        reloadMyPosts();
      } catch(e) {
        showMessage("Error unpinning post: " + e.message, true);
      }
    }
    async function loadPinnedPost() {
      if (!userAccount) return;
      try {
        const profile = await readOnlyContract.methods.getUserProfile(userAccount).call();
        const pinnedId = parseInt(profile[6],10);
        if (pinnedId > 0) {
          const post = await readOnlyContract.methods.getPost(pinnedId).call();
          if (post[0]) {
            // Show pinned post in My Profile
            if (window.location.hash === "#profile" || !window.location.hash) {
              const container = document.getElementById("myPinnedPostContent");
              if (container) {
                const me = await getUserDisplayName(userAccount);
                
                let contentHTML = post[8]
                  ? await renderRepost(post)
                  : getTruncatedContent(post[0], post[7]);
                
                container.innerHTML = `
                  <div class="postItem" onclick="window.location.hash='post${post[0]}'">
                    <div class="postHeader">
                      <div class="authorInfo">
                        ${getAvatarHTML(me)}
                        <div class="authorDetails">
                          <a href="#profile"><span class="authorName">${me.displayName}</span></a>
                          <div class="postDate">${formatTimestamp(post[3])}</div>
                        </div>
                      </div>
                      <div class="reactionRow">
                        <span class="reactionBtn like" title="Like" onclick="reactToPost(${post[0]}, 'like'); event.stopPropagation();"><i class="fas fa-thumbs-up"></i></span>
                        <span class="reactionBtn dislike" title="Dislike" onclick="reactToPost(${post[0]}, 'dislike'); event.stopPropagation();"><i class="fas fa-thumbs-down"></i></span>
                        <span class="reactionBtn shareBtn" title="Share" onclick="showShareOptions(${post[0]}, event); event.stopPropagation();"><i class="fas fa-share"></i></span>
                    </div>
                    </div>
                    <div class="postText"><p>${contentHTML}</p></div>
                    <div class="statsLine">Likes: ${post[5]} | Dislikes: ${post[6]} | Comments: ${post[4]} | Reposts: ${post[10]}</div>
                  </div>
                `;
                myPinnedPostPanel.style.display = "block";
              }
            }
          }
        } else {
          myPinnedPostPanel.style.display = "none";
        }
      } catch(e) {
        console.log("Error loading pinned post:", e);
      }
    }

    /* =================== Create a New Post =================== */
    async function createNewPost() {
      if (!userWeb3 || !userAccount) return showMessage("Connect wallet to create post.", true);
      if (!isRegistered) return showMessage("You must be registered to create posts.", true);

      const text = postContent.value.trim();
      if (!text) return showMessage("Post is empty!", true);

      try {
        await userContract.methods.createPost(text).send({ from: userAccount });
        showMessage("Post created!", false);
        postContent.value = "";
        reloadMyPosts();
        loadPinnedPost();
      } catch(e) {
        showMessage("Error creating post: " + e.message, true);
      }
    }

    /* =================== Settings & Registration =================== */
    function loadSettings() {
      const statusLine = document.getElementById("accountStatus");
      const updatesPanel = document.getElementById("profileUpdatesPanel");

      if (!userAccount) {
        statusLine.textContent = "Not connected.";
        if (updatesPanel) updatesPanel.style.display = "none";
        return;
      }
      if (!isRegistered) {
        statusLine.innerHTML = `
          You are NOT registered. <br/>
          <div class="panel" id="registrationPanelSettings">
            <h2>Register</h2>
            <p>Please register to create your profile:</p>
            <br>
            <input type="text" id="regNickname" placeholder="Nickname (your display name)" /><br/><br/>
            <input type="text" id="regUsername" placeholder="Username (at least 5 characters)" /><br/><br/>
            <button id="regNowBtn">Register</button>
          </div>
        `;
        if (updatesPanel) updatesPanel.style.display = "none";
        safeAddEventListener("regNowBtn", "click", doRegister);
      } else {
        statusLine.textContent = "Customize your profile.";
        if (updatesPanel) updatesPanel.style.display = "block";
        prefillProfileFields();
      }
    }
    async function doRegister() {
      if (!userAccount) return;
      const nn = document.getElementById("regNickname").value.trim();
      const un = document.getElementById("regUsername").value.trim();
      if (!nn || !un) return showMessage("Enter nickname & username", true);
      if (un.length < 5) return showMessage("Username must be at least 5 characters.", true);

      const existingAddr = await readOnlyContract.methods.getUserAddressByUsername(un).call();
      if (existingAddr !== "0x0000000000000000000000000000000000000000") {
        return showMessage("Username taken", true);
      }

      try {
        await userContract.methods.createAccount(nn, un).send({ from: userAccount });
        showMessage("Registration success!", false);
        refreshPage();
      } catch(e) {
        showMessage("Register error: " + e.message, true);
      }
    }
    async function prefillProfileFields() {
      try {
        const p = await userContract.methods.getUserProfile(userAccount).call();
        setNickname.value = p[0];
        setAbout.value = p[1];
        setWebsite.value = p[2];
        setLocation.value = p[3];
        setProfilePicture.value = p[4];
        setCoverPicture.value = p[5];

        const ub = await userContract.methods.getUserBasic(userAccount).call();
        setUsername.value = ub[1];
      } catch(e) {
        console.log("Prefill error:", e);
      }
    }
    async function updateUsername() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setUsername.value.trim();
      if (!val) return;

      const existingAddr = await readOnlyContract.methods.getUserAddressByUsername(val).call();
      if (existingAddr !== "0x0000000000000000000000000000000000000000") {
        return showMessage("Username taken", true);
      }
      try {
        await userContract.methods.changeUsername(val).send({ from: userAccount });
        showMessage("Username updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }
    async function updateNickname() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setNickname.value.trim();
      if (!val) return;
      try {
        await userContract.methods.updateNickname(val).send({ from: userAccount });
        showMessage("Nickname updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }
    async function updateAbout() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setAbout.value;
      try {
        await userContract.methods.updateAbout(val).send({ from: userAccount });
        showMessage("About updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }
    async function updateWebsite() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setWebsite.value.trim();
      try {
        await userContract.methods.updateWebsite(val).send({ from: userAccount });
        showMessage("Website updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }
    async function updateLocation() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setLocation.value.trim();
      try {
        await userContract.methods.updateLocation(val).send({ from: userAccount });
        showMessage("Location updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }
    async function updateProfilePicture() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setProfilePicture.value.trim();
      try {
        await userContract.methods.updateProfilePicture(val).send({ from: userAccount });
        showMessage("Profile picture updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }
    async function updateCoverPicture() {
      if (!isRegistered) return showMessage("Not registered", true);
      const val = setCoverPicture.value.trim();
      try {
        await userContract.methods.updateCoverPicture(val).send({ from: userAccount });
        showMessage("Cover picture updated.", false);
      } catch(e) {
        showMessage("Error: " + e.message, true);
      }
    }

    /* =================== Follow, Share, Recently Joined, Utility =================== */
    async function toggleFollow(userAddr, follow) {
      if (!userContract || !userAccount) return showMessage("Connect wallet to follow/unfollow.", true);
      try {
        await userContract.methods.followUser(userAddr, follow).send({ from: userAccount });
        showMessage("Follow status updated.", false);
        // Refresh the user profile:
        loadUserProfile((await getUserDisplayName(userAddr)).usernameOnly || userAddr);
      } catch(e) {
        showMessage("Error updating follow: " + e.message, true);
      }
    }
    async function loadRecentlyJoined() {
      try {
        const total = await readOnlyContract.methods.getTotalUsers().call();
        const recentContainer = document.getElementById("recentlyJoinedContent");
        recentContainer.innerHTML = "";
        let count = 0;

        for (let i = total; i>0 && count<5; i--) {
          const addr = await readOnlyContract.methods.getUserAddressById(i).call();
          if (addr === "0x0000000000000000000000000000000000000000") continue;

          const user = await getUserDisplayName(addr);
          const div = document.createElement("div");
          div.className = "recentUser";
          div.innerHTML = `
            <a href="#${user.usernameOnly ? user.usernameOnly : addr}">
              ${getAvatarHTML(user)}
              <span>${user.displayName}</span>
            </a>
          `;
          recentContainer.appendChild(div);
          count++;
        }
      } catch(e) {
        console.log("Error loading recently joined:", e);
      }
    }
    async function loadPlatformStats() {
      try {
        const totalUsers = await readOnlyContract.methods.getTotalUsers().call();
        const totalPosts = await readOnlyContract.methods.getGlobalPostCount().call();
        const statsContainer = document.getElementById("statsContent");
        statsContainer.innerHTML = "";
        
        if (totalUsers > 0 && totalPosts > 0) {
          statsContainer.innerHTML = `<strong>Total Users:</strong> ${totalUsers}<br><strong>Total Posts:</strong> ${totalPosts}`;
        }
      } catch(e) {
        console.log("Error loading recently joined:", e);
      }
    }
    async function getUserDisplayName(addr) {
      if (!addr) return { displayName: "", usernameOnly: null, profilePic: "" };
      if (userProfileCache[addr]) return userProfileCache[addr];

      try {
        const basic = await readOnlyContract.methods.getUserBasic(addr).call();
        const username = basic[1];
        const p = await readOnlyContract.methods.getUserProfile(addr).call();
        const display = `${p[0]} (@${username})`;
        const obj = { displayName: display, usernameOnly: username, profilePic: p[4] };
        userProfileCache[addr] = obj;
        return obj;
      } catch(e) {
        const fallback = { displayName: shortAddress(addr), usernameOnly: null, profilePic: "" };
        userProfileCache[addr] = fallback;
        return fallback;
      }
    }
    async function shareProfile() {
      const shareHash = currentUsername ? "#" + currentUsername : "#profile";
      const profileURL = window.location.origin + window.location.pathname + shareHash;
      try {
        await navigator.clipboard.writeText(profileURL);
        alert("Profile link copied:\n" + profileURL);
      } catch(e) {
        alert("Failed to copy link. Please copy manually:\n" + profileURL);
      }
    }

    /* =================== Share Modal =================== */
    function showShareOptions(postId, event) {
      event.stopPropagation();
      let existingModal = document.getElementById("shareModal");
      if (existingModal) existingModal.remove();

      let modal = document.createElement("div");
      modal.id = "shareModal";
      modal.innerHTML = `
        <div class="modal-overlay"></div>
        <div class="modal-content">
          <h3>Share Post</h3>
          <div class="share-buttons">
             <button id="modalRepostOption">Repost</button>
             <button id="modalShareLink">Share Link</button>
          </div>
          <button id="closeModal" class="close-modal">X</button>
        </div>
      `;
      document.body.appendChild(modal);

      safeAddEventListener("modalRepostOption", "click", () => {
        window.location.hash = "repost-" + postId;
        closeShareModal();
      });
      safeAddEventListener("modalShareLink", "click", () => {
        const postURL = window.location.origin + window.location.pathname + "#post" + postId;
        navigator.clipboard.writeText(postURL).then(() => {
          alert("Post link copied:\n" + postURL);
          closeShareModal();
        });
      });
      safeAddEventListener("closeModal", "click", closeShareModal);
      safeAddEventListener("shareModal", "click", (e) => {
        if (e.target.classList.contains("modal-overlay")) {
          closeShareModal();
        }
      });
    }
    function closeShareModal() {
      const modal = document.getElementById("shareModal");
      if (modal) modal.remove();
    }

    /* =================== THEME MANAGEMENT =================== */
    function initTheme() {
      const savedTheme = localStorage.getItem("zetherTheme") || "light";
      applyTheme(savedTheme);
      const themeSelector = document.getElementById("themeSelector");
      if (themeSelector) {
        themeSelector.value = savedTheme;
        themeSelector.addEventListener("change", function() {
          const newTheme = themeSelector.value;
          applyTheme(newTheme);
          localStorage.setItem("zetherTheme", newTheme);
        });
      }
    }
    function applyTheme(theme) {
      document.body.classList.remove("light-theme","dim-theme","dark-theme");
      if (theme === "dim") document.body.classList.add("dim-theme");
      else if (theme === "dark") document.body.classList.add("dark-theme");
      else document.body.classList.add("light-theme");
    }
  </script>
</body>
</html>
